version:
  run_id: "83361561022b40d3"
  target: Tofino
error_mode: propagate_and_disable
phv ingress:
  ig_intr_md.ingress_mac_tstamp.0-31: {  stage 0..1: W12 } 
  ig_intr_md.ingress_mac_tstamp.32-47: {  stage 0..1: W10(0..15) } 
  hdr.ethernet.dst_addr.0-31: W6
  hdr.ethernet.dst_addr.32-47: H13
  hdr.ethernet.src_addr.0-31: W7
  hdr.ethernet.src_addr.32-47: H14
  hdr.ethernet.ether_type: TH6
  hdr.ipv4.version: TB1(4..7)
  hdr.ipv4.ihl: TB1(0..3)
  hdr.ipv4.diffserv: TB2
  hdr.ipv4.total_len: H0
  hdr.ipv4.identification: TW0(16..31)
  hdr.ipv4.flags: TW0(13..15)
  hdr.ipv4.frag_offset: TW0(0..12)
  hdr.ipv4.ttl: B0
  hdr.ipv4.protocol: TB0
  hdr.ipv4.hdr_checksum: TH7
  hdr.ipv4.src_addr: TW1
  hdr.ipv4.dst_addr: W14
  hdr.validation.dfa_id: B5
  hdr.validation.dfa_state: B6
  hdr.validation.revf_length: TB3
  hdr.validation.datahash: W3
  hdr.validation.svf: W8
  hdr.pathmeta.path_length: B1
  hdr.path$0.transition_id: H5
  hdr.path$1.transition_id: H6
  hdr.path$2.transition_id: H7
  hdr.path$3.transition_id: {  stage 1..12: H8 } 
  hdr.path$4.transition_id: {  stage 1..12: H9 } 
  hdr.path$5.transition_id: {  stage 1..12: H10 } 
  hdr.path$6.transition_id: {  stage 1..12: H11 } 
  hdr.path$7.transition_id: {  stage 2..12: H12 } 
  hdr.revfs$0.revf: W0
  hdr.revfs$1.revf: W1
  hdr.revfs$2.revf: W2
  hdr.revfs$3.revf: TW2
  hdr.revfs$4.revf: TW3
  hdr.revfs$5.revf.0-15: TH0
  hdr.revfs$5.revf.16-31: TH1
  hdr.revfs$6.revf.0-15: TH2
  hdr.revfs$6.revf.16-31: TH3
  hdr.revfs$7.revf.0-15: TH4
  hdr.revfs$7.revf.16-31: TH5
  hdr.sip.svf: W9
  hdr.sip.datahash: W4
  hdr.sip.trans_id: W11(16..31)
  hdr.sip.timestamp.0-31: W13
  hdr.sip.timestamp.32-47: W11(0..15)
  hdr.sip.eg_port: TH8
  hdr.sip.trans_id_mem: H4
  cur_revf_0: {  stage 1: W5 } 
  ig_intr_md_for_tm.ucast_egress_port: {  stage 2..12: H1(0..8) } 
  ig_intr_md_for_dprsr.drop_ctl: {  stage 2..12: B4(0..2) } 
  ig_intr_md_for_dprsr.mirror_type: {  stage 12: B2(0..2) } 
  ig_md.trans_id: {  stage 1: W5(0..15) } 
  $tmp2: {  stage 12: H2(0..9) } 
  hdr.ethernet.$valid: B7(0)
  hdr.ipv4.$valid: B7(1)
  hdr.validation.$valid: B7(2)
  hdr.pathmeta.$valid: B7(3)
  hdr.sip.$valid: B7(4)
  hdr.path.$stkvalid: H3(0..8)
  hdr.path$0.$valid: {  stage 12: H3(7) } 
  hdr.path$1.$valid: {  stage 12: H3(6) } 
  hdr.path$2.$valid: {  stage 12: H3(5) } 
  hdr.path$3.$valid: {  stage 12: H3(4) } 
  hdr.path$4.$valid: {  stage 12: H3(3) } 
  hdr.path$5.$valid: {  stage 12: H3(2) } 
  hdr.path$6.$valid: {  stage 12: H3(1) } 
  hdr.path$7.$valid: H3(0)
  hdr.revfs.$stkvalid: B3
  hdr.revfs$0.$valid: {  stage 12: B3(7) } 
  hdr.revfs$1.$valid: {  stage 12: B3(6) } 
  hdr.revfs$2.$valid: {  stage 12: B3(5) } 
  hdr.revfs$3.$valid: {  stage 12: B3(4) } 
  hdr.revfs$4.$valid: {  stage 12: B3(3) } 
  hdr.revfs$5.$valid: {  stage 12: B3(2) } 
  hdr.revfs$6.$valid: {  stage 12: B3(1) } 
  hdr.revfs$7.$valid: B3(0)
phv egress:
parser ingress:
  start: $init_match
  init_zero: [ W5, B4, B2, H2, B7, H3, B3 ]
  bitwise_or: [ B3, B7, H3 ]
  hdr_len_adj: 16
  states:
    $init_match:
      *:
        0..3: W10  # bit[16..31] -> W10 bit[15..0]: ingress::ig_intr_md.ingress_mac_tstamp[47:32].32-47
        4..7: W12  # ingress::ig_intr_md.ingress_mac_tstamp[31:0].0-31
        H3: 256  # value 256 -> H3 bit[8..0]: ingress::hdr.path.$stkvalid
        load: { byte1 : 0 }
        shift: 8
        buf_req: 8
        next: hdr.path$shim.$entry_point.start
    hdr.path$shim.$entry_point.start:
      match: [ byte1 ]
      0b1*******:
        8..9: H13  # ingress::hdr.ethernet.dst_addr[47:32].32-47
        10..13: W6  # ingress::hdr.ethernet.dst_addr[31:0].0-31
        14..15: H14  # ingress::hdr.ethernet.src_addr[47:32].32-47
        16..19: W7  # ingress::hdr.ethernet.src_addr[31:0].0-31
        20..21: TH6  # ingress::hdr.ethernet.ether_type
        B7: 1  # value 1 -> B7 bit[0]: ingress::hdr.ethernet.$valid
        load: { half : 20..21 }
        shift: 22
        buf_req: 22
        next: start_0
      0b0*******:
        8..9: H13  # ingress::hdr.ethernet.dst_addr[47:32].32-47
        10..13: W6  # ingress::hdr.ethernet.dst_addr[31:0].0-31
        14..15: H14  # ingress::hdr.ethernet.src_addr[47:32].32-47
        16..19: W7  # ingress::hdr.ethernet.src_addr[31:0].0-31
        20..21: TH6  # ingress::hdr.ethernet.ether_type
        B7: 1  # value 1 -> B7 bit[0]: ingress::hdr.ethernet.$valid
        load: { half : 20..21 }
        shift: 22
        buf_req: 22
        next: start_0
    start_0:
      match: [ half ]
      0x0800:
        0: TB1
            # - bit[0..3] -> TB1 bit[7..4]: ingress::hdr.ipv4.version
            # - bit[4..7] -> TB1 bit[3..0]: ingress::hdr.ipv4.ihl
        1: TB2  # ingress::hdr.ipv4.diffserv
        2..3: H0  # ingress::hdr.ipv4.total_len
        4..7: TW0
            # - bit[32..47] -> TW0 bit[31..16]: ingress::hdr.ipv4.identification
            # - bit[48..50] -> TW0 bit[15..13]: ingress::hdr.ipv4.flags
            # - bit[51..63] -> TW0 bit[12..0]: ingress::hdr.ipv4.frag_offset
        8: B0  # ingress::hdr.ipv4.ttl
        9: TB0  # ingress::hdr.ipv4.protocol
        10..11: TH7  # ingress::hdr.ipv4.hdr_checksum
        12..15: TW1  # ingress::hdr.ipv4.src_addr
        16..19: W14  # ingress::hdr.ipv4.dst_addr
        load: { byte1 : 9 }
        shift: 20
        buf_req: 20
        next: parse_ipv4.$split_0
      0x****:
        buf_req: 0
        next: end
    parse_ipv4.$split_0:
      match: [ byte1 ]
      0xf0:
        B7: 2  # value 1 -> B7 bit[1]: ingress::hdr.ipv4.$valid
        load: { byte1 : 2 }
        buf_req: 3
        next: parse_validation
      0xf2:
        B7: 2  # value 1 -> B7 bit[1]: ingress::hdr.ipv4.$valid
        buf_req: 0
        next: parse_sip
      0x**:
        B7: 2  # value 1 -> B7 bit[1]: ingress::hdr.ipv4.$valid
        buf_req: 0
        next: end
    parse_validation:
      match: [ byte1 ]
      0x00:
        0: B5  # ingress::hdr.validation.dfa_id
        1: B6  # ingress::hdr.validation.dfa_state
        2: TB3  # ingress::hdr.validation.revf_length
        3..6: W3  # ingress::hdr.validation.datahash
        7..10: W8  # ingress::hdr.validation.svf
        B7: 4  # value 1 -> B7 bit[2]: ingress::hdr.validation.$valid
        load: { byte1 : 11 }
        shift: 11
        buf_req: 12
        next: parse_path_meta
      0x**:
        0: B5  # ingress::hdr.validation.dfa_id
        1: B6  # ingress::hdr.validation.dfa_state
        2: TB3  # ingress::hdr.validation.revf_length
        3..6: W3  # ingress::hdr.validation.datahash
        7..10: W8  # ingress::hdr.validation.svf
        B7: 4  # value 1 -> B7 bit[2]: ingress::hdr.validation.$valid
        load: { byte1 : 2 }
        shift: 11
        buf_req: 11
        next: parse_revfs_1
    parse_path_meta:
      match: [ byte1 ]
      0x00:
        0: B1  # ingress::hdr.pathmeta.path_length
        B7: 8  # value 1 -> B7 bit[3]: ingress::hdr.pathmeta.$valid
        shift: 1
        buf_req: 1
        next: end
      0x**:
        0: B1  # ingress::hdr.pathmeta.path_length
        B7: 8  # value 1 -> B7 bit[3]: ingress::hdr.pathmeta.$valid
        1..2: H5  # ingress::hdr.path[0].transition_id
        H3: 128  # value 128 -> H3 bit[8..0]: ingress::hdr.path.$stkvalid
        load: { byte1 : 0 }
        shift: 3
        buf_req: 3
        next: parse_path_1
    parse_path_1:
      match: [ byte1 ]
      0x01:
        buf_req: 0
        next: end
      0x**:
        0..1: H6  # ingress::hdr.path[1].transition_id
        H3: 64  # value 64 -> H3 bit[8..0]: ingress::hdr.path.$stkvalid
        shift: 2
        buf_req: 2
        next: parse_path_2
    parse_path_2:
      match: [ byte1 ]
      0x02:
        buf_req: 0
        next: end
      0x**:
        0..1: H7  # ingress::hdr.path[2].transition_id
        H3: 32  # value 32 -> H3 bit[8..0]: ingress::hdr.path.$stkvalid
        shift: 2
        buf_req: 2
        next: end
    parse_revfs_1:
      match: [ byte1 ]
      0x01:
        0..3: W0  # ingress::hdr.revfs[0].revf
        B3: 128  # value 128 -> B3 bit[7..0]: ingress::hdr.revfs.$stkvalid
        load: { byte1 : 4 }
        shift: 4
        buf_req: 5
        next: parse_path_meta
      0x**:
        0..3: W0  # ingress::hdr.revfs[0].revf
        B3: 128  # value 128 -> B3 bit[7..0]: ingress::hdr.revfs.$stkvalid
        shift: 4
        buf_req: 4
        next: parse_revfs_2
    parse_revfs_2:
      match: [ byte1 ]
      0x02:
        0..3: W1  # ingress::hdr.revfs[1].revf
        B3: 64  # value 64 -> B3 bit[7..0]: ingress::hdr.revfs.$stkvalid
        load: { byte1 : 4 }
        shift: 4
        buf_req: 5
        next: parse_path_meta
      0x**:
        0..3: W1  # ingress::hdr.revfs[1].revf
        B3: 96
        4..7: W2  # ingress::hdr.revfs[2].revf
        shift: 8
        buf_req: 8
        next: end
    parse_sip:
      *:
        0..3: W9  # ingress::hdr.sip.svf
        4..7: W4  # ingress::hdr.sip.datahash
        8..11: W11
            # - bit[64..79] -> W11 bit[31..16]: ingress::hdr.sip.trans_id
            # - bit[80..95] -> W11 bit[15..0]: ingress::hdr.sip.timestamp[47:32].32-47
        12..15: W13  # ingress::hdr.sip.timestamp[31:0].0-31
        16..17: TH8  # ingress::hdr.sip.eg_port
        18..19: H4  # ingress::hdr.sip.trans_id_mem
        B7: 16  # value 1 -> B7 bit[4]: ingress::hdr.sip.$valid
        load: { byte1 : 22 }
        shift: 20
        buf_req: 23
        next: parse_validation
deparser ingress:
  dictionary:
    H13: B7(0)  # ingress::hdr.ethernet.dst_addr.32-47 if ingress::hdr.ethernet.$valid
    W6: B7(0)  # ingress::hdr.ethernet.dst_addr.0-31 if ingress::hdr.ethernet.$valid
    H14: B7(0)  # ingress::hdr.ethernet.src_addr.32-47 if ingress::hdr.ethernet.$valid
    W7: B7(0)  # ingress::hdr.ethernet.src_addr.0-31 if ingress::hdr.ethernet.$valid
    TH6: B7(0)  # ingress::hdr.ethernet.ether_type if ingress::hdr.ethernet.$valid
    TB1: B7(1)
        # - bit[7..4]: ingress::hdr.ipv4.version if ingress::hdr.ipv4.$valid
        # - bit[3..0]: ingress::hdr.ipv4.ihl if ingress::hdr.ipv4.$valid
    TB2: B7(1)  # ingress::hdr.ipv4.diffserv if ingress::hdr.ipv4.$valid
    H0: B7(1)  # ingress::hdr.ipv4.total_len if ingress::hdr.ipv4.$valid
    TW0: B7(1)
        # - bit[31..16]: ingress::hdr.ipv4.identification if ingress::hdr.ipv4.$valid
        # - bit[15..13]: ingress::hdr.ipv4.flags if ingress::hdr.ipv4.$valid
        # - bit[12..0]: ingress::hdr.ipv4.frag_offset if ingress::hdr.ipv4.$valid
    B0: B7(1)  # ingress::hdr.ipv4.ttl if ingress::hdr.ipv4.$valid
    TB0: B7(1)  # ingress::hdr.ipv4.protocol if ingress::hdr.ipv4.$valid
    TH7: B7(1)  # ingress::hdr.ipv4.hdr_checksum if ingress::hdr.ipv4.$valid
    TW1: B7(1)  # ingress::hdr.ipv4.src_addr if ingress::hdr.ipv4.$valid
    W14: B7(1)  # ingress::hdr.ipv4.dst_addr if ingress::hdr.ipv4.$valid
    W9: B7(4)  # ingress::hdr.sip.svf if ingress::hdr.sip.$valid
    W4: B7(4)  # ingress::hdr.sip.datahash if ingress::hdr.sip.$valid
    W11: B7(4)
        # - bit[31..16]: ingress::hdr.sip.trans_id if ingress::hdr.sip.$valid
        # - bit[15..0]: ingress::hdr.sip.timestamp.32-47 if ingress::hdr.sip.$valid
    W13: B7(4)  # ingress::hdr.sip.timestamp.0-31 if ingress::hdr.sip.$valid
    TH8: B7(4)  # ingress::hdr.sip.eg_port if ingress::hdr.sip.$valid
    H4: B7(4)  # ingress::hdr.sip.trans_id_mem if ingress::hdr.sip.$valid
    B5: B7(2)  # ingress::hdr.validation.dfa_id if ingress::hdr.validation.$valid
    B6: B7(2)  # ingress::hdr.validation.dfa_state if ingress::hdr.validation.$valid
    TB3: B7(2)  # ingress::hdr.validation.revf_length if ingress::hdr.validation.$valid
    W3: B7(2)  # ingress::hdr.validation.datahash if ingress::hdr.validation.$valid
    W8: B7(2)  # ingress::hdr.validation.svf if ingress::hdr.validation.$valid
    W0: B3(7)  # ingress::hdr.revfs[0].revf if ingress::hdr.revfs[0].$valid
    W1: B3(6)  # ingress::hdr.revfs[1].revf if ingress::hdr.revfs[1].$valid
    W2: B3(5)  # ingress::hdr.revfs[2].revf if ingress::hdr.revfs[2].$valid
    TW2: B3(4)  # ingress::hdr.revfs[3].revf if ingress::hdr.revfs[3].$valid
    TW3: B3(3)  # ingress::hdr.revfs[4].revf if ingress::hdr.revfs[4].$valid
    TH1: B3(2)  # ingress::hdr.revfs[5].revf.16-31 if ingress::hdr.revfs[5].$valid
    TH0: B3(2)  # ingress::hdr.revfs[5].revf.0-15 if ingress::hdr.revfs[5].$valid
    TH3: B3(1)  # ingress::hdr.revfs[6].revf.16-31 if ingress::hdr.revfs[6].$valid
    TH2: B3(1)  # ingress::hdr.revfs[6].revf.0-15 if ingress::hdr.revfs[6].$valid
    TH5: B3(0)  # ingress::hdr.revfs[7].revf.16-31 if ingress::hdr.revfs[7].$valid
    TH4: B3(0)  # ingress::hdr.revfs[7].revf.0-15 if ingress::hdr.revfs[7].$valid
    B1: B7(3)  # ingress::hdr.pathmeta.path_length if ingress::hdr.pathmeta.$valid
    H5: H3(7)  # ingress::hdr.path[0].transition_id if ingress::hdr.path[0].$valid
    H6: H3(6)  # ingress::hdr.path[1].transition_id if ingress::hdr.path[1].$valid
    H7: H3(5)  # ingress::hdr.path[2].transition_id if ingress::hdr.path[2].$valid
    H8: H3(4)  # ingress::hdr.path[3].transition_id if ingress::hdr.path[3].$valid
    H9: H3(3)  # ingress::hdr.path[4].transition_id if ingress::hdr.path[4].$valid
    H10: H3(2)  # ingress::hdr.path[5].transition_id if ingress::hdr.path[5].$valid
    H11: H3(1)  # ingress::hdr.path[6].transition_id if ingress::hdr.path[6].$valid
    H12: H3(0)  # ingress::hdr.path[7].transition_id if ingress::hdr.path[7].$valid
  egress_unicast_port: H1(0..8)  # bit[8..0]: ingress::ig_intr_md_for_tm.ucast_egress_port
  drop_ctl: B4(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.drop_ctl
  mirror:
    select: B2(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.mirror_type
    0:
      - H2(0..9)  # bit[9..0]: ingress::$tmp2
parser egress:
  start: $entry_point.start
  hdr_len_adj: 0
  meta_opt: 0
  states:
    $entry_point.start:
      *:
        buf_req: 0
        next: end
deparser egress:
  dictionary: {}
stage 0 ingress:
  phase0_match SwitchIngressParser.$PORT_METADATA:
    p4:
      name: SwitchIngressParser.$PORT_METADATA
      size: 288
      preferred_match_type: exact
      match_type: exact
    size: 288
    p4_param_order:
      ig_intr_md.ingress_port: { type: exact, size: 9 }
    format: {ig_intr_md: 0..63}
    constant_value: 0
    actions:
      set_port_metadata:
      - handle: 0x20000000
      - p4_param_order: { ig_intr_md: 64 } 
  exact_match dfa_trans_0 0:
    p4: { name: SwitchIngress.dfa_trans, size: 512 }
    p4_param_order: 
      hdr.validation.dfa_id: { type: exact, size: 8, full_size: 8 }
      hdr.validation.dfa_state: { type: exact, size: 8, full_size: 8 }
    row: 7
    bus: 0
    column: [ 2, 3, 4, 5 ]
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - { group: 0, index: 0..9, select: 40..51 & 0x0, rams: [[7, 2]] }
      - { group: 0, index: 10..19, select: 40..51 & 0x0, rams: [[7, 3]] }
      - { group: 0, index: 20..29, select: 40..51 & 0x0, rams: [[7, 4]] }
      - { group: 0, index: 30..39, select: 40..51 & 0x0, rams: [[7, 5]] }
    input_xbar:
      exact group 0: { 0: hdr.validation.dfa_id, 8: hdr.validation.dfa_state }
      hash 0:
        0..7: random(hdr.validation.dfa_state(2..7)) ^ hdr.validation.dfa_id
        8..9: random(hdr.validation.dfa_state(2..7)) ^ hdr.validation.dfa_state(0..1)
        11..18: random(hdr.validation.dfa_state(2..7)) ^ hdr.validation.dfa_id
        19: random(hdr.validation.dfa_state(2..7)) ^ hdr.validation.dfa_state(0)
        10: random(hdr.validation.dfa_state(2..7)) ^ hdr.validation.dfa_state(1)
        22..29: random(hdr.validation.dfa_state(2..7)) ^ hdr.validation.dfa_id
        20..21: random(hdr.validation.dfa_state(2..7)) ^ hdr.validation.dfa_state(0..1)
        33..39: random(hdr.validation.dfa_state(2..7)) ^ hdr.validation.dfa_id(0..6)
        30: random(hdr.validation.dfa_state(2..7)) ^ hdr.validation.dfa_id(7)
        31..32: random(hdr.validation.dfa_state(2..7)) ^ hdr.validation.dfa_state(0..1)
      hash group 0:
        table: [0]
        seed: 0x8aac779260
    format: { action(0): 0..1, immediate(0): 4..27, version(0): 112..115, match(0): 58..63, action(1): 2..3, immediate(1): 28..51, version(1): 116..119, match(1): 66..71 }
    match: [ hdr.validation.dfa_state(2..7) ]
    match_group_map: [ [ 0, 1 ] ]
    gateway:
      name: cond-7
      input_xbar:
        exact group 0: { 20: hdr.sip.$valid }
      row: 0
      bus: 1
      unit: 1
      match: { 4: hdr.sip.$valid }
      0x1:
        next:  tbl_dfa428
      miss:
        run_table: true
      condition: 
        expression: "(hdr.sip.$valid == 1)"
        true:  tbl_dfa428
        false:  dfa_trans_0
    hit: [  to_hash_0 ]
    miss:  to_hash_0
    action_bus: { 2 : immediate(16..23), 96..99 : immediate(0..23) }
    instruction: dfa_trans_0(action, $DEFAULT)
    actions:
      SwitchIngress.dfa_transition(1, 1):
      - p4_param_order: { state: 8, transition_id: 16 }
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x2000000a
      - next_table: 0
      - { transition_id_1: immediate(0..15), transition_id: transition_id_1, state_1: immediate(16..23), state: state_1 }
      - set hdr.validation.dfa_state, state
      - set ig_md.trans_id, transition_id
      NoAction(2, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x2000000b
      - next_table: 0
      - {  }
    default_action: NoAction
  ternary_match tbl_dfa428 1:
    p4: { name: tbl_dfa428, hidden: true }
    gateway:
      name: cond-8
      input_xbar:
        exact group 0: { 24: hdr.pathmeta.path_length }
      row: 0
      bus: 0
      unit: 0
      match: { 0: hdr.pathmeta.path_length }
      0x00:
        run_table: true
      miss:
        next:  tbl_dfa431
      condition: 
        expression: "(hdr.pathmeta.path_length == 0)"
        true:  tbl_dfa428
        false:  tbl_dfa431
    hit: [  tbl_dfa448 ]
    miss:  tbl_dfa448
    indirect: tbl_dfa428$tind
  ternary_indirect tbl_dfa428$tind:
    row: 0
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_dfa428$tind(action, $DEFAULT)
    actions:
      dfa428(1, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000001
      - next_table: 0
      - set cur_revf_0, hdr.revfs$0.revf
    default_action: dfa428
  ternary_match tbl_dfa431 2:
    p4: { name: tbl_dfa431, hidden: true }
    gateway:
      name: cond-9
      input_xbar:
        exact group 0: { 24: hdr.pathmeta.path_length }
      row: 7
      bus: 0
      unit: 0
      match: { 0: hdr.pathmeta.path_length }
      0x01:
        run_table: true
      miss:
        next:  tbl_dfa434
      condition: 
        expression: "(hdr.pathmeta.path_length == 1)"
        true:  tbl_dfa431
        false:  tbl_dfa434
    hit: [  tbl_dfa448 ]
    miss:  tbl_dfa448
    indirect: tbl_dfa431$tind
  ternary_indirect tbl_dfa431$tind:
    row: 0
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_dfa431$tind(action, $DEFAULT)
    actions:
      dfa431(1, 4):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000002
      - next_table: 0
      - set cur_revf_0, hdr.revfs$1.revf
    default_action: dfa431
  ternary_match tbl_dfa434 3:
    p4: { name: tbl_dfa434, hidden: true }
    gateway:
      name: cond-10
      input_xbar:
        exact group 0: { 24: hdr.pathmeta.path_length }
      row: 1
      bus: 0
      unit: 0
      match: { 0: hdr.pathmeta.path_length }
      0x02:
        run_table: true
      miss:
        next:  tbl_dfa448
      condition: 
        expression: "(hdr.pathmeta.path_length == 2)"
        true:  tbl_dfa434
        false:  tbl_dfa448
    hit: [  tbl_dfa448 ]
    miss:  tbl_dfa448
    indirect: tbl_dfa434$tind
  ternary_indirect tbl_dfa434$tind:
    row: 1
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_dfa434$tind(action, $DEFAULT)
    actions:
      dfa434(1, 6):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000003
      - next_table: 0
      - set cur_revf_0, hdr.revfs$2.revf
    default_action: dfa434
stage 1 ingress:
  dependency: match
  ternary_match tbl_dfa448 1:
    p4: { name: tbl_dfa448, hidden: true }
    gateway:
      name: cond-11
      input_xbar:
        exact group 0: { 0: hdr.sip.datahash, 32: cur_revf_0 }
      row: 0
      bus: 0
      unit: 0
      match: { 0: cur_revf_0(0..7), 8: cur_revf_0(8..15), 16: cur_revf_0(16..23), 24: cur_revf_0(24..31) }
      xor: { 0: hdr.sip.datahash(0..7), 8: hdr.sip.datahash(8..15), 16: hdr.sip.datahash(16..23), 24: hdr.sip.datahash(24..31) }
      0x00000000:
        run_table: true
      miss:
        next:  tbl_drop
      condition: 
        expression: "(cur_revf_0 == hdr.sip.datahash)"
        true:  tbl_dfa448
        false:  tbl_drop
    hit: [  ipv4_lpm_0 ]
    miss:  ipv4_lpm_0
    indirect: tbl_dfa448$tind
  ternary_indirect tbl_dfa448$tind:
    row: 1
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_dfa448$tind(action, $DEFAULT)
    actions:
      dfa448(1, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000004
      - next_table: 0
      - set hdr.validation.svf, hdr.sip.svf
      - set hdr.path$7.transition_id, hdr.path$6.transition_id
      - set hdr.path$6.transition_id, hdr.path$5.transition_id
      - set hdr.path$5.transition_id, hdr.path$4.transition_id
      - set hdr.path$4.transition_id, hdr.path$3.transition_id
      - set hdr.path$3.transition_id, hdr.path$2.transition_id
      - set hdr.path$2.transition_id, hdr.path$1.transition_id
      - set hdr.path$1.transition_id, hdr.path$0.transition_id
      - set hdr.path.$stkvalid(0..7), hdr.path.$stkvalid(1..8)
      - set hdr.path$0.transition_id, hdr.sip.trans_id_mem
      - set hdr.sip.$valid, 0
      - add B1, 1, B1
      - add H0, 1, H0
    default_action: dfa448
  ternary_match tbl_drop 2:
    p4: { name: tbl_drop, hidden: true }
    hit: [  tbl_dfa445 ]
    miss:  tbl_dfa445
    indirect: tbl_drop$tind
  ternary_indirect tbl_drop$tind:
    row: 1
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_drop$tind(action, $DEFAULT)
    actions:
      SwitchIngress.drop(0, 3):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000008
      - next_table: 0
      - set ig_intr_md_for_dprsr.drop_ctl, 1
    default_action: SwitchIngress.drop
  ternary_match tbl_dfa445 3:
    p4: { name: tbl_dfa445, hidden: true }
    hit: [  END ]
    miss:  END
    indirect: tbl_dfa445$tind
  ternary_indirect tbl_dfa445$tind:
    row: 0
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_dfa445$tind(action, $DEFAULT)
    actions:
      dfa445(0, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000009
      - next_table: 0
    default_action: dfa445
  ternary_match ipv4_lpm_0 4:
    p4: { name: SwitchIngress.ipv4_lpm, size: 1024 }
    p4_param_order: 
      hdr.ipv4.dst_addr: { type: lpm, size: 32, full_size: 32 }
    row: [ 0, 1 ]
    bus: [ 0, 0 ]
    column:
    - 0
    - 0
    input_xbar:
      ternary group 0: { 0: hdr.ipv4.dst_addr }
    match:
    - { group: 0, byte_config: 3, dirtcam: 0x55 }
    gateway:
      name: cond-12
      input_xbar:
        exact group 0: { 65: hdr.ipv4.$valid }
      row: 0
      bus: 1
      unit: 1
      match: { 1: hdr.ipv4.$valid }
      0x1:
        run_table: true
      miss:
        next:  END
      condition: 
        expression: "(hdr.ipv4.$valid == 1)"
        true:  ipv4_lpm_0
        false:  END
    hit: [  END ]
    miss:  END
    indirect: ipv4_lpm_0$tind
  ternary_indirect ipv4_lpm_0$tind:
    row: 0
    bus: 0
    column: 2
    input_xbar:
      ternary group 0: { 0: hdr.ipv4.dst_addr }
    format: { action: 0..1 }
    action: ipv4_lpm_0$action_data($DIRECT, $DEFAULT)
    instruction: ipv4_lpm_0$tind(action, $DEFAULT)
    actions:
      SwitchIngress.ipv4_forward(1, 4):
      - p4_param_order: { dst_addr: 48, port: 9 }
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000005
      - next_table: 0
      - { port: $adf_h0(0..8), dst_addr_1.32-47: $adf_h1(0..15), dst_addr.32-47: dst_addr_1.32-47, dst_addr_1.0-31: $adf_f1(0..31), dst_addr.0-31: dst_addr_1.0-31 }
      - set ig_intr_md_for_tm.ucast_egress_port, port
      - set hdr.ethernet.src_addr.0-31, hdr.ethernet.dst_addr.0-31
      - set hdr.ethernet.src_addr.32-47, hdr.ethernet.dst_addr.32-47
      - set hdr.ethernet.dst_addr.0-31, dst_addr.0-31
      - set hdr.ethernet.dst_addr.32-47, dst_addr.32-47
      - add B0, 255, B0
      SwitchIngress.drop(2, 5):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000006
      - next_table: 0
      - {  }
      - set ig_intr_md_for_dprsr.drop_ctl, 1
      NoAction(3, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000007
      - next_table: 0
      - {  }
    default_action: SwitchIngress.drop
  action ipv4_lpm_0$action_data:
    p4: { name: SwitchIngress.ipv4_lpm$action }
    row: 15
    logical_bus: A
    column: 0
    vpns: [ 0 ]
    home_row:
    - 15
    format SwitchIngress.ipv4_forward: { $adf_h0: 0..15, $adf_h1: 16..31, $adf_f1: 32..63 }
    action_bus: { 36..37 : $adf_h0, 38..39 : $adf_h1, 100..103 : $adf_f1 }
  ternary_match to_hash_0 0:
    p4: { name: SwitchIngress.to_hash, size: 1 }
    hit: [  END ]
    miss:  END
    indirect: to_hash_0$tind
  ternary_indirect to_hash_0$tind:
    row: 2
    bus: 0
    format: { action: 0..0, immediate: 1..9 }
    action_bus: { 32..33 : immediate(0..8) }
    instruction: to_hash_0$tind(action, $DEFAULT)
    actions:
      SwitchIngress.send_to_hash(0, 1):
      - p4_param_order: { eg_port: 9 }
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x2000000c
      - next_table: 0
      - { eg_port_1: immediate(0..8), eg_port: eg_port_1 }
      - set hdr.sip.$valid, 1
      - set hdr.sip.svf, hdr.validation.svf
      - set hdr.sip.datahash, hdr.validation.datahash
      - set hdr.sip.timestamp.0-31, ig_intr_md.ingress_mac_tstamp.0-31
      - set ig_intr_md_for_tm.ucast_egress_port, eg_port
      - deposit-field W11(16..31), W5(0..15), W10
    default_action: SwitchIngress.send_to_hash
    default_action_parameters:
      eg_port: "0x14"


primitives: "dfa.prim.json"
dynhash: "dfa.dynhash.json"
