version:
  run_id: "e2e468469aa94a64"
  target: Tofino
error_mode: propagate_and_disable
phv ingress:
  ig_intr_md.ingress_port: {  stage 0: H0(0..8) } 
  hdr.ethernet.dst_addr.0-31: TW7
  hdr.ethernet.dst_addr.32-47: TH18
  hdr.ethernet.src_addr.0-31: TW6
  hdr.ethernet.src_addr.32-39: TB5
  hdr.ethernet.src_addr.40-47: TB6
  hdr.ethernet.ether_type: TH11
  hdr.ipv4.version: TW4(28..31)
  hdr.ipv4.ihl: TW4(24..27)
  hdr.ipv4.diffserv: TW4(16..23)
  hdr.ipv4.total_len: TW4(0..15)
  hdr.ipv4.identification: TW5(16..31)
  hdr.ipv4.flags: TW5(13..15)
  hdr.ipv4.frag_offset: TW5(0..12)
  hdr.ipv4.ttl: TB4
  hdr.ipv4.protocol: B3
  hdr.ipv4.hdr_checksum: TH6
  hdr.ipv4.src_addr.0-15: TH9
  hdr.ipv4.src_addr.16-31: TH10
  hdr.ipv4.dst_addr.0-15: TH7
  hdr.ipv4.dst_addr.16-31: TH8
  hdr.sip.m_0: W3
  hdr.sip.m_1: W36
  hdr.sip.m_2: W1
  hdr.sip.m_3: W15
  hdr.sip.m_4: W0
  hdr.sip_meta.v_0: W10
  hdr.sip_meta.v_1: W11
  hdr.sip_meta.v_2: W13
  hdr.sip_meta.v_3: W12
  hdr.sip_meta.dest_port: H1
  hdr.sip_meta.curr_round: B2
  hdr.sip_meta.revf_result: W37
  ig_md.sip_tmp.a_0: {  stage 3..10: W7 } 
  ig_md.sip_tmp.a_1: {  stage 3..10: W2 } 
  ig_md.sip_tmp.a_2: {  stage 3..10: W8 } 
  ig_md.sip_tmp.a_3: {  stage 3..10: W9 } 
  ig_md.sip_tmp.i_0: {  stage 1..10: W14 } 
  ig_md.sip_tmp.i_1: {  stage 4..9: W6 } 
  ig_md.sip_tmp.i_2: {  stage 4..9: W5 } 
  ig_md.sip_tmp.i_3: {  stage 4..9: W4 } 
  ig_md.rnd_port_for_recirc: {  stage 2..11: H3(0..8) } 
  ig_md.rnd_bit: {  stage 1: B1(3) } 
  ig_intr_md_for_tm.ucast_egress_port: {  stage 12: H2(0..8) } 
  ig_intr_md_for_dprsr.drop_ctl: {  stage 1..12: B1(0..2) } 
  ig_intr_md_for_dprsr.mirror_type: {  stage 12: B0(0..2) } 
  $tmp2: {  stage 12: H4(0..9) } 
  hdr.ethernet.$valid: B4(0)
  hdr.ipv4.$valid: B4(1)
  hdr.sip.$valid: B4(2)
  hdr.sip_meta.$valid: B4(3)
phv egress:
  hdr.min_parse_depth_padding_0$0.packet_payload.0-31: TW2
  hdr.min_parse_depth_padding_0$0.packet_payload.32-63: TW3
  hdr.min_parse_depth_padding_0$0.packet_payload.64-79: TH15
  hdr.min_parse_depth_padding_0$0.packet_payload.80-87: TB0
  hdr.min_parse_depth_padding_0$1.packet_payload.0-15: TH1
  hdr.min_parse_depth_padding_0$1.packet_payload.16-31: TH2
  hdr.min_parse_depth_padding_0$1.packet_payload.32-47: TH3
  hdr.min_parse_depth_padding_0$1.packet_payload.48-63: TH4
  hdr.min_parse_depth_padding_0$1.packet_payload.64-79: TH16
  hdr.min_parse_depth_padding_0$1.packet_payload.80-87: TB1
  hdr.min_parse_depth_padding_0$2.packet_payload.0-31: TW8
  hdr.min_parse_depth_padding_0$2.packet_payload.32-63: TW9
  hdr.min_parse_depth_padding_0$2.packet_payload.64-79: TH17
  hdr.min_parse_depth_padding_0$2.packet_payload.80-87: TB2
  eg_intr_md.egress_port: H16(0..8)
  hdr.ethernet.dst_addr.0-31: TW11
  hdr.ethernet.dst_addr.32-47: TH24
  hdr.ethernet.src_addr.0-31: TW10
  hdr.ethernet.src_addr.32-39: TB10
  hdr.ethernet.src_addr.40-47: TB11
  hdr.ethernet.ether_type.0-7: TB8
  hdr.ethernet.ether_type.8-15: TB9
  hdr.ipv4.version: TW0(28..31)
  hdr.ipv4.ihl: TW0(24..27)
  hdr.ipv4.diffserv: TW0(16..23)
  hdr.ipv4.total_len: TW0(0..15)
  hdr.ipv4.identification: TW1(16..31)
  hdr.ipv4.flags: TW1(13..15)
  hdr.ipv4.frag_offset: TW1(0..12)
  hdr.ipv4.ttl: TB3
  hdr.ipv4.protocol: B18
  hdr.ipv4.hdr_checksum: TH0
  hdr.ipv4.src_addr.0-15: TH13
  hdr.ipv4.src_addr.16-31: TH14
  hdr.ipv4.dst_addr.0-15: TH5
  hdr.ipv4.dst_addr.16-31: TH12
  hdr.sip.m_0: W34
  hdr.sip.m_1: W17
  hdr.sip.m_2: W30
  hdr.sip.m_3: W16
  hdr.sip.m_4: W32
  hdr.sip_meta.v_0: W22
  hdr.sip_meta.v_1: W23
  hdr.sip_meta.v_2: W19
  hdr.sip_meta.v_3: W25
  hdr.sip_meta.dest_port: TH1
  hdr.sip_meta.curr_round: B16
  hdr.sip_meta.revf_result: W33
  eg_md.sip_tmp.a_0: {  stage 3..9: W26 } 
  eg_md.sip_tmp.a_1: {  stage 3..9: W18 } 
  eg_md.sip_tmp.a_2: {  stage 3..9: W27 } 
  eg_md.sip_tmp.a_3: {  stage 3..9: W28 } 
  eg_md.sip_tmp.i_0: {  stage 1..9: W29 } 
  eg_md.sip_tmp.i_1: {  stage 4..8: W24 } 
  eg_md.sip_tmp.i_2: {  stage 4..8: W21 } 
  eg_md.sip_tmp.i_3: {  stage 4..8: W20 } 
  hdr.ethernet.$valid: B19(0)
  hdr.ipv4.$valid: B19(1)
  hdr.sip.$valid: B19(2)
  hdr.sip_meta.$valid: B19(3)
  hdr.min_parse_depth_padding_0.$stkvalid: B17(0..2)
  hdr.min_parse_depth_padding_0$0.$valid: B17(2)
  hdr.min_parse_depth_padding_0$1.$valid: {  stage 12: B17(1) } 
  hdr.min_parse_depth_padding_0$2.$valid: B17(0)
parser ingress:
  start: $init_match
  init_zero: [ H3, B1, B0, H4, B4 ]
  bitwise_or: [ B4 ]
  hdr_len_adj: 16
  states:
    $init_match:
      *:
        0..1: H0  # bit[7..15] -> H0 bit[8..0]: ingress::ig_intr_md.ingress_port
        load: { byte1 : 0 }
        shift: 8
        buf_req: 8
        next: $entry_point.start
    $entry_point.start:
      match: [ byte1 ]
      0b1*******:
        8..9: TH18  # ingress::hdr.ethernet.dst_addr[47:32].32-47
        10..13: TW7  # ingress::hdr.ethernet.dst_addr[31:0].0-31
        14: TB6  # ingress::hdr.ethernet.src_addr[47:40].40-47
        15: TB5  # ingress::hdr.ethernet.src_addr[39:32].32-39
        16..19: TW6  # ingress::hdr.ethernet.src_addr[31:0].0-31
        20..21: TH11  # ingress::hdr.ethernet.ether_type
        B4: 1  # value 1 -> B4 bit[0]: ingress::hdr.ethernet.$valid
        load: { half : 20..21 }
        shift: 22
        buf_req: 22
        next: start_0
      0b0*******:
        8..9: TH18  # ingress::hdr.ethernet.dst_addr[47:32].32-47
        10..13: TW7  # ingress::hdr.ethernet.dst_addr[31:0].0-31
        14: TB6  # ingress::hdr.ethernet.src_addr[47:40].40-47
        15: TB5  # ingress::hdr.ethernet.src_addr[39:32].32-39
        16..19: TW6  # ingress::hdr.ethernet.src_addr[31:0].0-31
        20..21: TH11  # ingress::hdr.ethernet.ether_type
        B4: 1  # value 1 -> B4 bit[0]: ingress::hdr.ethernet.$valid
        load: { half : 20..21 }
        shift: 22
        buf_req: 22
        next: start_0
    start_0:
      match: [ half ]
      0x0800:
        0..3: TW4
            # - bit[0..3] -> TW4 bit[31..28]: ingress::hdr.ipv4.version
            # - bit[4..7] -> TW4 bit[27..24]: ingress::hdr.ipv4.ihl
            # - bit[8..15] -> TW4 bit[23..16]: ingress::hdr.ipv4.diffserv
            # - bit[16..31] -> TW4 bit[15..0]: ingress::hdr.ipv4.total_len
        4..7: TW5
            # - bit[32..47] -> TW5 bit[31..16]: ingress::hdr.ipv4.identification
            # - bit[48..50] -> TW5 bit[15..13]: ingress::hdr.ipv4.flags
            # - bit[51..63] -> TW5 bit[12..0]: ingress::hdr.ipv4.frag_offset
        8: TB4  # ingress::hdr.ipv4.ttl
        9: B3  # ingress::hdr.ipv4.protocol
        10..11: TH6  # ingress::hdr.ipv4.hdr_checksum
        12..13: TH10  # ingress::hdr.ipv4.src_addr[31:16].16-31
        14..15: TH9  # ingress::hdr.ipv4.src_addr[15:0].0-15
        16..17: TH8  # ingress::hdr.ipv4.dst_addr[31:16].16-31
        B4: 2  # value 1 -> B4 bit[1]: ingress::hdr.ipv4.$valid
        load: { byte1 : 9 }
        shift: 18
        buf_req: 18
        next: parse_ipv4.$split_0
      0x****:
        buf_req: 0
        next: end
    parse_ipv4.$split_0:
      match: [ byte1 ]
      0xf0:
        0..1: TH7  # ingress::hdr.ipv4.dst_addr[15:0].0-15
        2..5: W3  # ingress::hdr.sip.m_0
        6..9: W36  # ingress::hdr.sip.m_1
        10..13: W1  # ingress::hdr.sip.m_2
        14..17: W15  # ingress::hdr.sip.m_3
        B4: 4  # value 1 -> B4 bit[2]: ingress::hdr.sip.$valid
        shift: 18
        buf_req: 18
        next: parse_sip.$split_0
      0xf1:
        0..1: TH7  # ingress::hdr.ipv4.dst_addr[15:0].0-15
        2..5: W3  # ingress::hdr.sip.m_0
        6..9: W36  # ingress::hdr.sip.m_1
        10..13: W1  # ingress::hdr.sip.m_2
        14..17: W15  # ingress::hdr.sip.m_3
        B4: 12
            # - value 1 -> B4 bit[2]: ingress::hdr.sip.$valid
            # - value 1 -> B4 bit[3]: ingress::hdr.sip_meta.$valid
        shift: 18
        buf_req: 18
        next: parse_sip_and_meta.$split_0
      0xf2:
        0..1: TH7  # ingress::hdr.ipv4.dst_addr[15:0].0-15
        2..5: W3  # ingress::hdr.sip.m_0
        6..9: W36  # ingress::hdr.sip.m_1
        10..13: W1  # ingress::hdr.sip.m_2
        14..17: W15  # ingress::hdr.sip.m_3
        B4: 12
            # - value 1 -> B4 bit[2]: ingress::hdr.sip.$valid
            # - value 1 -> B4 bit[3]: ingress::hdr.sip_meta.$valid
        shift: 18
        buf_req: 18
        next: parse_sip_and_meta.$split_0
      0x**:
        0..1: TH7  # ingress::hdr.ipv4.dst_addr[15:0].0-15
        shift: 2
        buf_req: 2
        next: end
    parse_sip.$split_0:
      *:
        0..3: W0  # ingress::hdr.sip.m_4
        shift: 4
        buf_req: 4
        next: end
    parse_sip_and_meta.$split_0:
      *:
        0..3: W0  # ingress::hdr.sip.m_4
        4..7: W10  # ingress::hdr.sip_meta.v_0
        8..11: W11  # ingress::hdr.sip_meta.v_1
        12..15: W13  # ingress::hdr.sip_meta.v_2
        20..21: H1  # ingress::hdr.sip_meta.dest_port
        22: B2  # ingress::hdr.sip_meta.curr_round
        shift: 16
        buf_req: 23
        next: parse_sip_and_meta.$split_1
    parse_sip_and_meta.$split_1:
      *:
        0..3: W12  # ingress::hdr.sip_meta.v_3
        7..10: W37  # ingress::hdr.sip_meta.revf_result
        shift: 11
        buf_req: 11
        next: end
deparser ingress:
  dictionary:
    TH18: B4(0)  # ingress::hdr.ethernet.dst_addr.32-47 if ingress::hdr.ethernet.$valid
    TW7: B4(0)  # ingress::hdr.ethernet.dst_addr.0-31 if ingress::hdr.ethernet.$valid
    TB6: B4(0)  # ingress::hdr.ethernet.src_addr.40-47 if ingress::hdr.ethernet.$valid
    TB5: B4(0)  # ingress::hdr.ethernet.src_addr.32-39 if ingress::hdr.ethernet.$valid
    TW6: B4(0)  # ingress::hdr.ethernet.src_addr.0-31 if ingress::hdr.ethernet.$valid
    TH11: B4(0)  # ingress::hdr.ethernet.ether_type if ingress::hdr.ethernet.$valid
    TW4: B4(1)
        # - bit[31..28]: ingress::hdr.ipv4.version if ingress::hdr.ipv4.$valid
        # - bit[27..24]: ingress::hdr.ipv4.ihl if ingress::hdr.ipv4.$valid
        # - bit[23..16]: ingress::hdr.ipv4.diffserv if ingress::hdr.ipv4.$valid
        # - bit[15..0]: ingress::hdr.ipv4.total_len if ingress::hdr.ipv4.$valid
    TW5: B4(1)
        # - bit[31..16]: ingress::hdr.ipv4.identification if ingress::hdr.ipv4.$valid
        # - bit[15..13]: ingress::hdr.ipv4.flags if ingress::hdr.ipv4.$valid
        # - bit[12..0]: ingress::hdr.ipv4.frag_offset if ingress::hdr.ipv4.$valid
    TB4: B4(1)  # ingress::hdr.ipv4.ttl if ingress::hdr.ipv4.$valid
    B3: B4(1)  # ingress::hdr.ipv4.protocol if ingress::hdr.ipv4.$valid
    TH6: B4(1)  # ingress::hdr.ipv4.hdr_checksum if ingress::hdr.ipv4.$valid
    TH10: B4(1)  # ingress::hdr.ipv4.src_addr.16-31 if ingress::hdr.ipv4.$valid
    TH9: B4(1)  # ingress::hdr.ipv4.src_addr.0-15 if ingress::hdr.ipv4.$valid
    TH8: B4(1)  # ingress::hdr.ipv4.dst_addr.16-31 if ingress::hdr.ipv4.$valid
    TH7: B4(1)  # ingress::hdr.ipv4.dst_addr.0-15 if ingress::hdr.ipv4.$valid
    W3: B4(2)  # ingress::hdr.sip.m_0 if ingress::hdr.sip.$valid
    W36: B4(2)  # ingress::hdr.sip.m_1 if ingress::hdr.sip.$valid
    W1: B4(2)  # ingress::hdr.sip.m_2 if ingress::hdr.sip.$valid
    W15: B4(2)  # ingress::hdr.sip.m_3 if ingress::hdr.sip.$valid
    W0: B4(2)  # ingress::hdr.sip.m_4 if ingress::hdr.sip.$valid
    W10: B4(3)  # ingress::hdr.sip_meta.v_0 if ingress::hdr.sip_meta.$valid
    W11: B4(3)  # ingress::hdr.sip_meta.v_1 if ingress::hdr.sip_meta.$valid
    W13: B4(3)  # ingress::hdr.sip_meta.v_2 if ingress::hdr.sip_meta.$valid
    W12: B4(3)  # ingress::hdr.sip_meta.v_3 if ingress::hdr.sip_meta.$valid
    H1: B4(3)  # ingress::hdr.sip_meta.dest_port if ingress::hdr.sip_meta.$valid
    B2: B4(3)  # ingress::hdr.sip_meta.curr_round if ingress::hdr.sip_meta.$valid
    W37: B4(3)  # ingress::hdr.sip_meta.revf_result if ingress::hdr.sip_meta.$valid
  egress_unicast_port: H2(0..8)  # bit[8..0]: ingress::ig_intr_md_for_tm.ucast_egress_port
  drop_ctl: B1(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.drop_ctl
  mirror:
    select: B0(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.mirror_type
    0:
      - H4(0..9)  # bit[9..0]: ingress::$tmp2
parser egress:
  start: $entry_point.start
  init_zero: [ B19, B17 ]
  bitwise_or: [ B17, B19 ]
  hdr_len_adj: 27
  meta_opt: 8191
  states:
    $entry_point.start:
      *:
        counter:
          imm: 24
        0..1: H16  # bit[7..15] -> H16 bit[8..0]: egress::eg_intr_md.egress_port
        27..28: TH24  # egress::hdr.ethernet.dst_addr[47:32].32-47
        B19: 1  # value 1 -> B19 bit[0]: egress::hdr.ethernet.$valid
        intr_md: 9
        shift: 29
        buf_req: 29
        next: $entry_point.start.$oob_stall_0
    $entry_point.start.$oob_stall_0:
      *:
        0..3: TW11  # egress::hdr.ethernet.dst_addr[31:0].0-31
        4: TB11  # egress::hdr.ethernet.src_addr[47:40].40-47
        5: TB10  # egress::hdr.ethernet.src_addr[39:32].32-39
        6..9: TW10  # egress::hdr.ethernet.src_addr[31:0].0-31
        10: TB9  # egress::hdr.ethernet.ether_type[15:8].8-15
        11: TB8  # egress::hdr.ethernet.ether_type[7:0].0-7
        load: { half : 10..11 }
        shift: 12
        buf_req: 12
        next: $entry_point.start.$split_0
    $entry_point.start.$split_0:
      match: [ half ]
      0x0800:
        counter: dec 20
        0..3: TW0
            # - bit[0..3] -> TW0 bit[31..28]: egress::hdr.ipv4.version
            # - bit[4..7] -> TW0 bit[27..24]: egress::hdr.ipv4.ihl
            # - bit[8..15] -> TW0 bit[23..16]: egress::hdr.ipv4.diffserv
            # - bit[16..31] -> TW0 bit[15..0]: egress::hdr.ipv4.total_len
        4..7: TW1
            # - bit[32..47] -> TW1 bit[31..16]: egress::hdr.ipv4.identification
            # - bit[48..50] -> TW1 bit[15..13]: egress::hdr.ipv4.flags
            # - bit[51..63] -> TW1 bit[12..0]: egress::hdr.ipv4.frag_offset
        8: TB3  # egress::hdr.ipv4.ttl
        9: B18  # egress::hdr.ipv4.protocol
        10..11: TH0  # egress::hdr.ipv4.hdr_checksum
        12..13: TH14  # egress::hdr.ipv4.src_addr[31:16].16-31
        14..15: TH13  # egress::hdr.ipv4.src_addr[15:0].0-15
        16..17: TH12  # egress::hdr.ipv4.dst_addr[31:16].16-31
        B19: 2  # value 1 -> B19 bit[1]: egress::hdr.ipv4.$valid
        load: { byte1 : 9 }
        shift: 18
        buf_req: 18
        next: parse_ipv4.$split_0
      0x****:
        buf_req: 0
        next: min_parse_depth_reject_initial
    parse_ipv4.$split_0:
      match: [ byte1 ]
      0xf0:
        counter: dec 20
        0..1: TH5  # egress::hdr.ipv4.dst_addr[15:0].0-15
        2..5: W34  # egress::hdr.sip.m_0
        6..9: W17  # egress::hdr.sip.m_1
        10..13: W30  # egress::hdr.sip.m_2
        14..17: W16  # egress::hdr.sip.m_3
        B19: 4  # value 1 -> B19 bit[2]: egress::hdr.sip.$valid
        shift: 18
        buf_req: 18
        next: parse_sip.$split_0
      0xf1:
        counter: dec 43
        0..1: TH5  # egress::hdr.ipv4.dst_addr[15:0].0-15
        2..5: W34  # egress::hdr.sip.m_0
        6..9: W17  # egress::hdr.sip.m_1
        10..13: W30  # egress::hdr.sip.m_2
        14..17: W16  # egress::hdr.sip.m_3
        B19: 12
            # - value 1 -> B19 bit[2]: egress::hdr.sip.$valid
            # - value 1 -> B19 bit[3]: egress::hdr.sip_meta.$valid
        shift: 18
        buf_req: 18
        next: parse_sip_and_meta.$split_0
      0xf2:
        counter: dec 43
        0..1: TH5  # egress::hdr.ipv4.dst_addr[15:0].0-15
        2..5: W34  # egress::hdr.sip.m_0
        6..9: W17  # egress::hdr.sip.m_1
        10..13: W30  # egress::hdr.sip.m_2
        14..17: W16  # egress::hdr.sip.m_3
        B19: 12
            # - value 1 -> B19 bit[2]: egress::hdr.sip.$valid
            # - value 1 -> B19 bit[3]: egress::hdr.sip_meta.$valid
        shift: 18
        buf_req: 18
        next: parse_sip_and_meta.$split_0
      0x**:
        0..1: TH5  # egress::hdr.ipv4.dst_addr[15:0].0-15
        shift: 2
        buf_req: 2
        next: min_parse_depth_accept_initial
    parse_sip.$split_0:
      *:
        0..3: W32  # egress::hdr.sip.m_4
        shift: 4
        buf_req: 4
        next: end
    parse_sip_and_meta.$split_0:
      *:
        0..3: W32  # egress::hdr.sip.m_4
        4..7: W22  # egress::hdr.sip_meta.v_0
        8..11: W23  # egress::hdr.sip_meta.v_1
        12..15: W19  # egress::hdr.sip_meta.v_2
        20..21: TH1  # egress::hdr.sip_meta.dest_port
        22: B16  # egress::hdr.sip_meta.curr_round
        shift: 16
        buf_req: 23
        next: parse_sip_and_meta.$split_1
    parse_sip_and_meta.$split_1:
      *:
        0..3: W25  # egress::hdr.sip_meta.v_3
        7..10: W33  # egress::hdr.sip_meta.revf_result
        shift: 11
        buf_req: 11
        next: end
    min_parse_depth_accept_initial:
      match: [ ctr_neg, ctr_zero ]
      option: ignore_max_depth
      0x0:
        counter: dec 11
        0: TB0  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[87:80].80-87
        1..2: TH15  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[79:64].64-79
        3..6: TW3  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[63:32].32-63
        7..10: TW2  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[31:0].0-31
        B17: 4  # value 4 -> B17 bit[2..0]: egress::hdr.min_parse_depth_padding_0.$stkvalid
        shift: 11
        buf_req: 11
        next: min_parse_depth_accept_loop.$split_0
      0b**:
        buf_req: 0
        next: end
    min_parse_depth_accept_loop.$split_0:
      match: [ ctr_neg, ctr_zero ]
      option: ignore_max_depth
      0x0:
        counter: dec 11
        0: TB1  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[87:80].80-87
        1..2: TH16  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[79:64].64-79
        3..4: TH4  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[63:48].48-63
        5..6: TH3  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[47:32].32-47
        7..8: TH2  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[31:16].16-31
        B17: 2  # value 2 -> B17 bit[2..0]: egress::hdr.min_parse_depth_padding_0.$stkvalid
        shift: 9
        buf_req: 9
        next: min_parse_depth_accept_loop.$it1.$split_0
      0b**:
        buf_req: 0
        next: end
    min_parse_depth_accept_loop.$it1.$split_0:
      match: [ ctr_neg, ctr_zero ]
      option: ignore_max_depth
      0x0:
        counter: dec 11
        0..1: TH1  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[15:0].0-15
        2: TB2  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[87:80].80-87
        3..4: TH17  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[79:64].64-79
        5..8: TW9  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[63:32].32-63
        9..12: TW8  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[31:0].0-31
        B17: 1  # value 1 -> B17 bit[2..0]: egress::hdr.min_parse_depth_padding_0.$stkvalid
        shift: 13
        buf_req: 13
        next: end
      0b**:
        0..1: TH1  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[15:0].0-15
        shift: 2
        buf_req: 2
        next: end
    min_parse_depth_reject_initial:
      match: [ ctr_neg, ctr_zero ]
      option: ignore_max_depth
      0x0:
        buf_req: 0
        next: min_parse_depth_reject_loop
      0b**:
        buf_req: 0
        next: end
    min_parse_depth_reject_loop:
      option: ignore_max_depth
      *:
        counter: dec 11
        buf_req: 0
        next: min_parse_depth_reject_loop.$split_0
    min_parse_depth_reject_loop.$split_0:
      match: [ ctr_neg, ctr_zero ]
      option: ignore_max_depth
      0x0:
        buf_req: 0
        next: min_parse_depth_reject_loop
      0b**:
        buf_req: 0
        next: end
deparser egress:
  dictionary:
    TH24: B19(0)  # egress::hdr.ethernet.dst_addr.32-47 if egress::hdr.ethernet.$valid
    TW11: B19(0)  # egress::hdr.ethernet.dst_addr.0-31 if egress::hdr.ethernet.$valid
    TB11: B19(0)  # egress::hdr.ethernet.src_addr.40-47 if egress::hdr.ethernet.$valid
    TB10: B19(0)  # egress::hdr.ethernet.src_addr.32-39 if egress::hdr.ethernet.$valid
    TW10: B19(0)  # egress::hdr.ethernet.src_addr.0-31 if egress::hdr.ethernet.$valid
    TB9: B19(0)  # egress::hdr.ethernet.ether_type.8-15 if egress::hdr.ethernet.$valid
    TB8: B19(0)  # egress::hdr.ethernet.ether_type.0-7 if egress::hdr.ethernet.$valid
    TW0: B19(1)
        # - bit[31..28]: egress::hdr.ipv4.version if egress::hdr.ipv4.$valid
        # - bit[27..24]: egress::hdr.ipv4.ihl if egress::hdr.ipv4.$valid
        # - bit[23..16]: egress::hdr.ipv4.diffserv if egress::hdr.ipv4.$valid
        # - bit[15..0]: egress::hdr.ipv4.total_len if egress::hdr.ipv4.$valid
    TW1: B19(1)
        # - bit[31..16]: egress::hdr.ipv4.identification if egress::hdr.ipv4.$valid
        # - bit[15..13]: egress::hdr.ipv4.flags if egress::hdr.ipv4.$valid
        # - bit[12..0]: egress::hdr.ipv4.frag_offset if egress::hdr.ipv4.$valid
    TB3: B19(1)  # egress::hdr.ipv4.ttl if egress::hdr.ipv4.$valid
    B18: B19(1)  # egress::hdr.ipv4.protocol if egress::hdr.ipv4.$valid
    TH0: B19(1)  # egress::hdr.ipv4.hdr_checksum if egress::hdr.ipv4.$valid
    TH14: B19(1)  # egress::hdr.ipv4.src_addr.16-31 if egress::hdr.ipv4.$valid
    TH13: B19(1)  # egress::hdr.ipv4.src_addr.0-15 if egress::hdr.ipv4.$valid
    TH12: B19(1)  # egress::hdr.ipv4.dst_addr.16-31 if egress::hdr.ipv4.$valid
    TH5: B19(1)  # egress::hdr.ipv4.dst_addr.0-15 if egress::hdr.ipv4.$valid
    W34: B19(2)  # egress::hdr.sip.m_0 if egress::hdr.sip.$valid
    W17: B19(2)  # egress::hdr.sip.m_1 if egress::hdr.sip.$valid
    W30: B19(2)  # egress::hdr.sip.m_2 if egress::hdr.sip.$valid
    W16: B19(2)  # egress::hdr.sip.m_3 if egress::hdr.sip.$valid
    W32: B19(2)  # egress::hdr.sip.m_4 if egress::hdr.sip.$valid
    W22: B19(3)  # egress::hdr.sip_meta.v_0 if egress::hdr.sip_meta.$valid
    W23: B19(3)  # egress::hdr.sip_meta.v_1 if egress::hdr.sip_meta.$valid
    W19: B19(3)  # egress::hdr.sip_meta.v_2 if egress::hdr.sip_meta.$valid
    W25: B19(3)  # egress::hdr.sip_meta.v_3 if egress::hdr.sip_meta.$valid
    TH1: B19(3)  # egress::hdr.sip_meta.dest_port if egress::hdr.sip_meta.$valid
    B16: B19(3)  # egress::hdr.sip_meta.curr_round if egress::hdr.sip_meta.$valid
    W33: B19(3)  # egress::hdr.sip_meta.revf_result if egress::hdr.sip_meta.$valid
    TB0: B17(2)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.80-87 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TH15: B17(2)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.64-79 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TW3: B17(2)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.32-63 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TW2: B17(2)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.0-31 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TB1: B17(1)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.80-87 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TH16: B17(1)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.64-79 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TH4: B17(1)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.48-63 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TH3: B17(1)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.32-47 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TH2: B17(1)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.16-31 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TH1: B17(1)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.0-15 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TB2: B17(0)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.80-87 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TH17: B17(0)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.64-79 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TW9: B17(0)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.32-63 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TW8: B17(0)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.0-31 if egress::hdr.min_parse_depth_padding_0[2].$valid
  egress_unicast_port: H16(0..8)  # bit[8..0]: egress::eg_intr_md.egress_port
stage 0 ingress:
  phase0_match SwitchIngressParser.$PORT_METADATA:
    p4:
      name: SwitchIngressParser.$PORT_METADATA
      size: 288
      preferred_match_type: exact
      match_type: exact
    size: 288
    p4_param_order:
      ig_intr_md.ingress_port: { type: exact, size: 9 }
    format: {ig_intr_md: 0..63}
    constant_value: 0
    actions:
      set_port_metadata:
      - handle: 0x20000000
      - p4_param_order: { ig_intr_md: 64 } 
  hash_action tbl_get_rnd_bit 0:
    p4: { name: tbl_get_rnd_bit, hidden: true }
    row: 0
    result_bus: 0
    gateway:
      name: cond-8
      input_xbar:
        exact group 0: { 2: hdr.sip.$valid }
      row: 7
      bus: 0
      unit: 0
      payload_row: 0
      payload_unit: 0
      payload: 0x1
      format: { action: 0..0 }
      match: { 2: hdr.sip.$valid }
      0x1:
        next:  tbl_start_first_pass_revf
      miss:
        run_table : true
      condition: 
        expression: "(hdr.sip.$valid == 1)"
        true:  tbl_start_first_pass_revf
        false:  tbl_drop
    next:  tbl_drop
    action_bus: { 0 : rng(0, 0..7) }
    instruction: tbl_get_rnd_bit(action, $DEFAULT)
    actions:
      SwitchIngress.get_rnd_bit(1, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000001c
      - next_table: 0
      - set B1(3..3), rng(0, 3..3)
    default_action: SwitchIngress.get_rnd_bit
  ternary_match tbl_drop 8:
    p4: { name: tbl_drop, hidden: true }
    hit: [  tbl_halfsiphash585 ]
    miss:  tbl_halfsiphash585
    indirect: tbl_drop$tind
  ternary_indirect tbl_drop$tind:
    row: 0
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_drop$tind(action, $DEFAULT)
    actions:
      SwitchIngress.drop(0, 7):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000023
      - next_table: 0
      - set ig_intr_md_for_dprsr.drop_ctl, 1
    default_action: SwitchIngress.drop
  ternary_match tbl_halfsiphash585 9:
    p4: { name: tbl_halfsiphash585, hidden: true }
    hit: [  END ]
    miss:  END
    indirect: tbl_halfsiphash585$tind
  ternary_indirect tbl_halfsiphash585$tind:
    row: 3
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_halfsiphash585$tind(action, $DEFAULT)
    actions:
      halfsiphash585(0, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000024
      - next_table: 0
    default_action: halfsiphash585
  ternary_match tbl_start_first_pass_revf 1:
    p4: { name: tbl_start_first_pass_revf, hidden: true }
    gateway:
      name: cond-9
      input_xbar:
        exact group 0: { 8: hdr.ipv4.protocol }
      row: 0
      bus: 1
      unit: 1
      match: { 0: hdr.ipv4.protocol }
      0xf0:
        run_table: true
      miss:
        next:  tbl_start_first_pass_svf
      condition: 
        expression: "(hdr.ipv4.protocol == 240)"
        true:  tbl_start_first_pass_revf
        false:  tbl_start_first_pass_svf
    hit: [  tbl_halfsiphash591 ]
    miss:  tbl_halfsiphash591
    indirect: tbl_start_first_pass_revf$tind
  ternary_indirect tbl_start_first_pass_revf$tind:
    row: 3
    bus: 0
    format: { action: 0..0 }
    action: tbl_start_first_pass_revf$action_data($DIRECT, $DEFAULT)
    instruction: tbl_start_first_pass_revf$tind(action, $DEFAULT)
    actions:
      SwitchIngress.start_first_pass_revf(1, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000001
      - next_table: 0
      - { $constant0: $adf_f0(0..31), $constant0: 858927408, $constant1: $adf_f1(0..31), $constant1: 1111570744, $constant2: $adf_f2(0..31), $constant2: 908352858, $constant3: $adf_f3(0..31), $constant3: 1598772821 }
      - set hdr.sip_meta.$valid, 1
      - set hdr.sip_meta.curr_round, 0
      - set hdr.sip_meta.v_0, $constant0
      - set hdr.sip_meta.v_1, $constant1
      - set hdr.sip_meta.v_2, $constant3
      - set hdr.sip_meta.v_3, $constant2
      - set ig_md.sip_tmp.i_0, hdr.sip.m_0
      - deposit-field H1(9..15), 0, H0
    default_action: SwitchIngress.start_first_pass_revf
  action tbl_start_first_pass_revf$action_data:
    p4: { name: tbl_start_first_pass_revf$action }
    row: 14
    logical_bus: A
    column: 4
    vpns: [ 0 ]
    home_row:
    - 14
    format SwitchIngress.start_first_pass_revf: { $adf_f0: 0..31, $adf_f1: 32..63, $adf_f2: 64..95, $adf_f3: 96..127 }
    action_bus: { 96..99 : $adf_f2, 100..103 : $adf_f3, 104..107 : $adf_f0, 108..111 : $adf_f1 }
  ternary_match tbl_start_first_pass_svf 2:
    p4: { name: tbl_start_first_pass_svf, hidden: true }
    gateway:
      name: cond-10
      input_xbar:
        exact group 0: { 8: hdr.ipv4.protocol, 16: hdr.sip_meta.revf_result(16..31), 32: hdr.sip_meta.revf_result(0..15) }
        hash 0:
          40..47: hdr.ipv4.protocol
        hash group 0:
          table: [0]
          seed: 0x0
      row: 0
      bus: 0
      unit: 0
      match: { 0: hdr.sip_meta.revf_result(0..7), 8: hdr.sip_meta.revf_result(8..15), 16: hdr.sip_meta.revf_result(16..23), 24: hdr.sip_meta.revf_result(24..31), 32: hdr.ipv4.protocol }
      0x**00000000:
        next:  tb_start_round_0
      0xf1********:
        run_table: true
      miss:
        next:  tb_start_round_0
      condition: 
        expression: "(hdr.ipv4.protocol == 241 && hdr.sip_meta.revf_result != 0)"
        true:  tbl_start_first_pass_svf
        false:  tb_start_round_0
    hit: [  tbl_halfsiphash595 ]
    miss:  tbl_halfsiphash595
    indirect: tbl_start_first_pass_svf$tind
  ternary_indirect tbl_start_first_pass_svf$tind:
    row: 2
    bus: 1
    format: { action: 0..0 }
    action: tbl_start_first_pass_svf$action_data($DIRECT, $DEFAULT)
    instruction: tbl_start_first_pass_svf$tind(action, $DEFAULT)
    actions:
      SwitchIngress.start_first_pass_svf(1, 4):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000007
      - next_table: 0
      - { $constant0: $adf_f0(0..31), $constant0: 858927408, $constant1: $adf_f1(0..31), $constant1: 1111570744, $constant2: $adf_f2(0..31), $constant2: 908352858, $constant3: $adf_f3(0..31), $constant3: 1598772821 }
      - set hdr.sip_meta.curr_round, 0
      - set hdr.sip_meta.v_0, $constant0
      - set hdr.sip_meta.v_1, $constant1
      - set hdr.sip_meta.v_2, $constant3
      - set hdr.sip_meta.v_3, $constant2
      - set hdr.sip.m_0, hdr.sip.m_4
      - set hdr.sip.m_1, 0
      - set hdr.sip.m_2, 0
      - set hdr.sip.m_3, 0
      - set ig_md.sip_tmp.i_0, hdr.sip.m_4
    default_action: SwitchIngress.start_first_pass_svf
  action tbl_start_first_pass_svf$action_data:
    p4: { name: tbl_start_first_pass_svf$action }
    row: 15
    logical_bus: A
    column: 0
    vpns: [ 0 ]
    home_row:
    - 15
    format SwitchIngress.start_first_pass_svf: { $adf_f0: 0..31, $adf_f1: 32..63, $adf_f2: 64..95, $adf_f3: 96..127 }
    action_bus: { 112..115 : $adf_f2, 116..119 : $adf_f3, 120..123 : $adf_f0, 124..127 : $adf_f1 }
  exact_match tb_start_round_0 3:
    p4: { name: SwitchIngress.tb_start_round, size: 32 }
    p4_param_order: 
      hdr.sip_meta.curr_round: { type: exact, size: 8, full_size: 8 }
    row: 7
    bus: 1
    column: 3
    stash: 
      row: [ 7 ]
      col: [ 3 ]
      unit: [ 1 ]
    ways:
      - { group: 0, index: 0..9, select: 40..51 & 0x0, rams: [[7, 3]] }
    input_xbar:
      exact group 0: { 48: hdr.sip_meta.curr_round }
      hash 0:
        0..7: hdr.sip_meta.curr_round
      hash group 0:
        table: [0]
        seed: 0x0
    format: { action(0): 0..1, immediate(0): 2..33, version(0): 112..115 }
    match_group_map: [ [ 0 ] ]
    hit: [  tbl_sip_1_odd ]
    miss:  tbl_sip_1_odd
    context_json:
      static_entries:
      - priority: 0
        match_key_fields_values:
        - field_name: hdr.sip_meta.curr_round
          value: "0x0"
        action_handle: 0x20000003
        is_default_entry: false
        action_parameters_values: []
      - priority: 1
        match_key_fields_values:
        - field_name: hdr.sip_meta.curr_round
          value: "0x4"
        action_handle: 0x20000004
        is_default_entry: false
        action_parameters_values: []
      - priority: 2
        match_key_fields_values:
        - field_name: hdr.sip_meta.curr_round
          value: "0x8"
        action_handle: 0x20000005
        is_default_entry: false
        action_parameters_values: []

    action_bus: { 64..67 : immediate(0..31) }
    instruction: tb_start_round_0(action, $DEFAULT)
    actions:
      SwitchIngress.start_m_0_compression(0, 6):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000003
      - next_table: 0
      - {  }
      - set ig_md.sip_tmp.i_0, hdr.sip.m_0
      SwitchIngress.start_m_2_compression(1, 8):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000004
      - next_table: 0
      - {  }
      - set ig_md.sip_tmp.i_0, hdr.sip.m_2
      SwitchIngress.start_finalization_a(2, 10):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000005
      - next_table: 0
      - { $constant0: immediate(0..31), $constant0: 255 }
      - set ig_md.sip_tmp.i_0, 0
      - xor W13, $constant0, W13
      NoAction(-1, 0):
      - hit_allowed: { allowed: false, reason: user_indicated_default_only }
      - default_only_action: { allowed: true }
      - handle: 0x20000006
      - next_table: 0
      - {  }
    default_only_action: NoAction
  ternary_match tbl_halfsiphash595 5:
    p4: { name: tbl_halfsiphash595, hidden: true }
    hit: [  tbl_sip_1_odd ]
    miss:  tbl_sip_1_odd
    indirect: tbl_halfsiphash595$tind
  ternary_indirect tbl_halfsiphash595$tind:
    row: 2
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_halfsiphash595$tind(action, $DEFAULT)
    actions:
      halfsiphash595(0, 3):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000008
      - next_table: 0
      - set hdr.ipv4.protocol, 242
    default_action: halfsiphash595
  ternary_match tbl_halfsiphash591 6:
    p4: { name: tbl_halfsiphash591, hidden: true }
    hit: [  tbl_sip_1_odd ]
    miss:  tbl_sip_1_odd
    indirect: tbl_halfsiphash591$tind
  ternary_indirect tbl_halfsiphash591$tind:
    row: 1
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_halfsiphash591$tind(action, $DEFAULT)
    actions:
      halfsiphash591(0, 5):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000002
      - next_table: 0
      - set hdr.ipv4.protocol, 241
    default_action: halfsiphash591
stage 1 ingress:
  dependency: match
  ternary_match tbl_sip_1_odd 1:
    p4: { name: tbl_sip_1_odd, hidden: true }
    hit: [  tbl_halfsiphash627 ]
    miss:  tbl_halfsiphash627
    indirect: tbl_sip_1_odd$tind
  ternary_indirect tbl_sip_1_odd$tind:
    row: 0
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_sip_1_odd$tind(action, $DEFAULT)
    actions:
      SwitchIngress.sip_1_odd(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000009
      - next_table: 0
      - xor W12, W12, W14
    default_action: SwitchIngress.sip_1_odd
  ternary_match tbl_halfsiphash627 2:
    p4: { name: tbl_halfsiphash627, hidden: true }
    gateway:
      name: cond-11
      input_xbar:
        exact group 0: { 3: ig_md.rnd_bit }
      row: 0
      bus: 0
      unit: 0
      match: { 3: ig_md.rnd_bit }
      0x0:
        run_table: true
      miss:
        next:  tbl_halfsiphash629
      condition: 
        expression: "(ig_md.rnd_bit == 0)"
        true:  tbl_halfsiphash627
        false:  tbl_halfsiphash629
    hit: [  tbl_sip_1_b ]
    miss:  tbl_sip_1_b
    indirect: tbl_halfsiphash627$tind
  ternary_indirect tbl_halfsiphash627$tind:
    row: 0
    bus: 0
    format: { action: 0..0, immediate: 1..9 }
    action_bus: { 32..33 : immediate(0..8) }
    instruction: tbl_halfsiphash627$tind(action, $DEFAULT)
    actions:
      halfsiphash627(1, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000001d
      - next_table: 0
      - { $constant0: immediate(0..8), $constant0: 68 }
      - set ig_md.rnd_port_for_recirc, $constant0
    default_action: halfsiphash627
  ternary_match tbl_halfsiphash629 3:
    p4: { name: tbl_halfsiphash629, hidden: true }
    hit: [  tbl_sip_1_b ]
    miss:  tbl_sip_1_b
    indirect: tbl_halfsiphash629$tind
  ternary_indirect tbl_halfsiphash629$tind:
    row: 1
    bus: 1
    format: { action: 0..0, immediate: 1..9 }
    action_bus: { 36..37 : immediate(0..8) }
    instruction: tbl_halfsiphash629$tind(action, $DEFAULT)
    actions:
      halfsiphash629(0, 4):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000001e
      - next_table: 0
      - { $constant0: immediate(0..8), $constant0: 196 }
      - set ig_md.rnd_port_for_recirc, $constant0
    default_action: halfsiphash629
stage 2 ingress:
  dependency: action
  ternary_match tbl_sip_1_b 2:
    p4: { name: tbl_sip_1_b, hidden: true }
    hit: [  tbl_sip_1_a ]
    miss:  tbl_sip_1_a
    indirect: tbl_sip_1_b$tind
  ternary_indirect tbl_sip_1_b$tind:
    row: 0
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_sip_1_b$tind(action, $DEFAULT)
    actions:
      SwitchIngress.sip_1_b(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000000b
      - next_table: 0
      - deposit-field W9(0..31), W12(24), W9
    default_action: SwitchIngress.sip_1_b
  hash_action tbl_sip_1_a 3:
    p4: { name: tbl_sip_1_a, hidden: true }
    row: 0
    result_bus: 1
    hash_dist:
      2: { hash: 0, mask: 0xffff, shift: 0 }
      3: { hash: 1, mask: 0xffff, shift: 0 }
    input_xbar:
      exact group 0: { 32: hdr.sip_meta.v_1 }
      hash 0:
        32..36: hdr.sip_meta.v_1(27..31)
        37..47: hdr.sip_meta.v_1(0..10)
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 0: { 64: hdr.sip_meta.v_1 }
      hash 1:
        0..15: hdr.sip_meta.v_1(11..26)
      hash group 1:
        table: [1]
        seed: 0x0
    gateway:
      name: tbl_sip_1_a-gateway
      row: 0
      bus: 0
      unit: 1
      0x0:  tbl_sip_2_a
      miss:  tbl_sip_2_a
      condition: 
        expression: "true(always hit)"
        true:  tbl_sip_2_a
        false:  tbl_sip_2_a
    next: []
    action_bus: { 100..103 : hash_dist(2, 3) }
    instruction: tbl_sip_1_a($DEFAULT, $DEFAULT)
    actions:
      SwitchIngress.sip_1_a(0, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000000a
      - next_table: 0
      - set W2(0..31), hash_dist(2, 3, 0..31)
      - add W7, W10, W11
      - add W8, W12, W13
    default_action: SwitchIngress.sip_1_a
stage 3 ingress:
  dependency: action
  ternary_match tbl_sip_2_a 1:
    p4: { name: tbl_sip_2_a, hidden: true }
    hit: [  tbl_sip_3_a ]
    miss:  tbl_sip_3_a
    indirect: tbl_sip_2_a$tind
  ternary_indirect tbl_sip_2_a$tind:
    row: 0
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_sip_2_a$tind(action, $DEFAULT)
    actions:
      SwitchIngress.sip_2_a(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000000c
      - next_table: 0
      - set ig_md.sip_tmp.i_2, ig_md.sip_tmp.a_2
      - xor W4, W8, W9
      - xor W6, W2, W7
      - deposit-field W14(0..31), W7(16), W14
    default_action: SwitchIngress.sip_2_a
stage 4 ingress:
  dependency: match
  hash_action tbl_sip_3_a 1:
    p4: { name: tbl_sip_3_a, hidden: true }
    row: 0
    result_bus: 0
    hash_dist:
      2: { hash: 0, mask: 0xffff, shift: 0 }
      3: { hash: 1, mask: 0xffff, shift: 0 }
    input_xbar:
      exact group 0: { 32: ig_md.sip_tmp.i_1 }
      hash 0:
        32..44: ig_md.sip_tmp.i_1(19..31)
        45..47: ig_md.sip_tmp.i_1(0..2)
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 0: { 64: ig_md.sip_tmp.i_1 }
      hash 1:
        0..15: ig_md.sip_tmp.i_1(3..18)
      hash group 1:
        table: [1]
        seed: 0x0
    gateway:
      name: tbl_sip_3_a-gateway
      row: 0
      bus: 0
      unit: 0
      0x0:  tbl_sip_3_b
      miss:  tbl_sip_3_b
      condition: 
        expression: "true(always hit)"
        true:  tbl_sip_3_b
        false:  tbl_sip_3_b
    next: []
    action_bus: { 100..103 : hash_dist(2, 3) }
    instruction: tbl_sip_3_a($DEFAULT, $DEFAULT)
    actions:
      SwitchIngress.sip_3_a(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000000d
      - next_table: 0
      - set W2(0..31), hash_dist(2, 3, 0..31)
      - add W7, W4, W14
      - add W8, W5, W6
    default_action: SwitchIngress.sip_3_a
stage 5 ingress:
  dependency: action
  hash_action tbl_sip_3_b 0:
    p4: { name: tbl_sip_3_b, hidden: true }
    row: 0
    result_bus: 0
    hash_dist:
      0: { hash: 0, mask: 0xffff, shift: 0 }
      1: { hash: 0, mask: 0xffff, shift: 0 }
    input_xbar:
      exact group 0: { 0: ig_md.sip_tmp.i_3 }
      hash 0:
        0..6: ig_md.sip_tmp.i_3(25..31)
        7..15: ig_md.sip_tmp.i_3(0..8)
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 0: { 0: ig_md.sip_tmp.i_3 }
      hash 0:
        16..31: ig_md.sip_tmp.i_3(9..24)
      hash group 0:
        table: [0]
        seed: 0x0
    gateway:
      name: tbl_sip_3_b-gateway
      row: 0
      bus: 0
      unit: 0
      0x0:  tbl_sip_4_b_odd
      miss:  tbl_sip_4_b_odd
      condition: 
        expression: "true(always hit)"
        true:  tbl_sip_4_b_odd
        false:  tbl_sip_4_b_odd
    next: []
    action_bus: { 96..99 : hash_dist(0, 1) }
    instruction: tbl_sip_3_b($DEFAULT, $DEFAULT)
    actions:
      SwitchIngress.sip_3_b(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000000e
      - next_table: 0
      - set W9(0..31), hash_dist(0, 1, 0..31)
    default_action: SwitchIngress.sip_3_b
  ternary_match tbl_sip_4_b_odd 3:
    p4: { name: tbl_sip_4_b_odd, hidden: true }
    hit: [  tbl_sip_4_a ]
    miss:  tbl_sip_4_a
    indirect: tbl_sip_4_b_odd$tind
  ternary_indirect tbl_sip_4_b_odd$tind:
    row: 1
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_sip_4_b_odd$tind(action, $DEFAULT)
    actions:
      SwitchIngress.sip_4_b_odd(0, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000010
      - next_table: 0
      - set hdr.sip_meta.v_0, ig_md.sip_tmp.a_0
    default_action: SwitchIngress.sip_4_b_odd
stage 6 ingress:
  dependency: match
  ternary_match tbl_sip_4_a 0:
    p4: { name: tbl_sip_4_a, hidden: true }
    hit: [  tbl_sip_1_b_0 ]
    miss:  tbl_sip_1_b_0
    indirect: tbl_sip_4_a$tind
  ternary_indirect tbl_sip_4_a$tind:
    row: 0
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_sip_4_a$tind(action, $DEFAULT)
    actions:
      SwitchIngress.sip_4_a(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000000f
      - next_table: 0
      - xor W11, W2, W8
      - xor W12, W7, W9
      - deposit-field W13(0..31), W8(16), W13
    default_action: SwitchIngress.sip_4_a
stage 7 ingress:
  dependency: match
  ternary_match tbl_sip_1_b_0 0:
    p4: { name: tbl_sip_1_b_0, hidden: true }
    hit: [  tbl_sip_1_a_0 ]
    miss:  tbl_sip_1_a_0
    indirect: tbl_sip_1_b_0$tind
  ternary_indirect tbl_sip_1_b_0$tind:
    row: 0
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_sip_1_b_0$tind(action, $DEFAULT)
    actions:
      SwitchIngress.sip_1_b(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000012
      - next_table: 0
      - deposit-field W9(0..31), W12(24), W9
    default_action: SwitchIngress.sip_1_b
  hash_action tbl_sip_1_a_0 1:
    p4: { name: tbl_sip_1_a_0, hidden: true }
    row: 0
    result_bus: 0
    hash_dist:
      0: { hash: 0, mask: 0xffff, shift: 0 }
      1: { hash: 0, mask: 0xffff, shift: 0 }
    input_xbar:
      exact group 0: { 0: hdr.sip_meta.v_1 }
      hash 0:
        0..4: hdr.sip_meta.v_1(27..31)
        5..15: hdr.sip_meta.v_1(0..10)
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 0: { 0: hdr.sip_meta.v_1 }
      hash 0:
        16..31: hdr.sip_meta.v_1(11..26)
      hash group 0:
        table: [0]
        seed: 0x0
    gateway:
      name: tbl_sip_1_a_0-gateway
      row: 0
      bus: 0
      unit: 0
      0x0:  tbl_sip_2_a_0
      miss:  tbl_sip_2_a_0
      condition: 
        expression: "true(always hit)"
        true:  tbl_sip_2_a_0
        false:  tbl_sip_2_a_0
    next: []
    action_bus: { 96..99 : hash_dist(0, 1) }
    instruction: tbl_sip_1_a_0($DEFAULT, $DEFAULT)
    actions:
      SwitchIngress.sip_1_a(0, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000011
      - next_table: 0
      - set W2(0..31), hash_dist(0, 1, 0..31)
      - add W7, W10, W11
      - add W8, W12, W13
    default_action: SwitchIngress.sip_1_a
stage 8 ingress:
  dependency: action
  ternary_match tbl_sip_2_a_0 0:
    p4: { name: tbl_sip_2_a_0, hidden: true }
    hit: [  tbl_sip_3_a_0 ]
    miss:  tbl_sip_3_a_0
    indirect: tbl_sip_2_a_0$tind
  ternary_indirect tbl_sip_2_a_0$tind:
    row: 0
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_sip_2_a_0$tind(action, $DEFAULT)
    actions:
      SwitchIngress.sip_2_a(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000013
      - next_table: 0
      - set ig_md.sip_tmp.i_2, ig_md.sip_tmp.a_2
      - xor W4, W8, W9
      - xor W6, W2, W7
      - deposit-field W14(0..31), W7(16), W14
    default_action: SwitchIngress.sip_2_a
stage 9 ingress:
  dependency: match
  hash_action tbl_sip_3_a_0 0:
    p4: { name: tbl_sip_3_a_0, hidden: true }
    row: 0
    result_bus: 1
    hash_dist:
      0: { hash: 0, mask: 0xffff, shift: 0 }
      1: { hash: 0, mask: 0xffff, shift: 0 }
    input_xbar:
      exact group 0: { 0: ig_md.sip_tmp.i_1 }
      hash 0:
        0..12: ig_md.sip_tmp.i_1(19..31)
        13..15: ig_md.sip_tmp.i_1(0..2)
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 0: { 0: ig_md.sip_tmp.i_1 }
      hash 0:
        16..31: ig_md.sip_tmp.i_1(3..18)
      hash group 0:
        table: [0]
        seed: 0x0
    gateway:
      name: tbl_sip_3_a_0-gateway
      row: 1
      bus: 0
      unit: 0
      0x0:  tbl_sip_3_b_0
      miss:  tbl_sip_3_b_0
      condition: 
        expression: "true(always hit)"
        true:  tbl_sip_3_b_0
        false:  tbl_sip_3_b_0
    next: []
    action_bus: { 96..99 : hash_dist(0, 1) }
    instruction: tbl_sip_3_a_0($DEFAULT, $DEFAULT)
    actions:
      SwitchIngress.sip_3_a(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000014
      - next_table: 0
      - set W2(0..31), hash_dist(0, 1, 0..31)
      - add W7, W4, W14
      - add W8, W5, W6
    default_action: SwitchIngress.sip_3_a
  hash_action tbl_sip_3_b_0 1:
    p4: { name: tbl_sip_3_b_0, hidden: true }
    row: 0
    result_bus: 0
    hash_dist:
      2: { hash: 0, mask: 0xffff, shift: 0 }
      3: { hash: 1, mask: 0xffff, shift: 0 }
    input_xbar:
      exact group 0: { 32: ig_md.sip_tmp.i_3 }
      hash 0:
        32..38: ig_md.sip_tmp.i_3(25..31)
        39..47: ig_md.sip_tmp.i_3(0..8)
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 0: { 64: ig_md.sip_tmp.i_3 }
      hash 1:
        0..15: ig_md.sip_tmp.i_3(9..24)
      hash group 1:
        table: [1]
        seed: 0x0
    gateway:
      name: tbl_sip_3_b_0-gateway
      row: 0
      bus: 0
      unit: 1
      0x0:  tb_pre_end_0
      miss:  tb_pre_end_0
      condition: 
        expression: "true(always hit)"
        true:  tb_pre_end_0
        false:  tb_pre_end_0
    next: []
    action_bus: { 100..103 : hash_dist(2, 3) }
    instruction: tbl_sip_3_b_0($DEFAULT, $DEFAULT)
    actions:
      SwitchIngress.sip_3_b(0, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000015
      - next_table: 0
      - set W9(0..31), hash_dist(2, 3, 0..31)
    default_action: SwitchIngress.sip_3_b
  exact_match tb_pre_end_0 3:
    p4: { name: SwitchIngress.tb_pre_end, size: 32 }
    p4_param_order: 
      hdr.sip_meta.curr_round: { type: exact, size: 8, full_size: 8 }
    row: 7
    bus: 0
    column: 2
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - { group: 2, index: 0..9, select: 40..51 & 0x0, rams: [[7, 2]] }
    input_xbar:
      exact group 1: { 0: hdr.sip_meta.curr_round }
      hash 2:
        0..7: hdr.sip_meta.curr_round
      hash group 2:
        table: [2]
        seed: 0x0
    format: { action(0): 0..1, version(0): 112..115, action(1): 2..3, version(1): 116..119, action(2): 4..5, version(2): 120..123, action(3): 6..7, version(3): 124..127, action(4): 8..9, version(4): 16..19 }
    match_group_map: [ [ 0, 1, 2, 3, 4 ] ]
    hit: [  tbl_sip_4_a_0 ]
    miss:  tbl_sip_4_a_0
    context_json:
      static_entries:
      - priority: 0
        match_key_fields_values:
        - field_name: hdr.sip_meta.curr_round
          value: "0x0"
        action_handle: 0x20000016
        is_default_entry: false
        action_parameters_values: []
      - priority: 1
        match_key_fields_values:
        - field_name: hdr.sip_meta.curr_round
          value: "0x4"
        action_handle: 0x20000017
        is_default_entry: false
        action_parameters_values: []
      - priority: 2
        match_key_fields_values:
        - field_name: hdr.sip_meta.curr_round
          value: "0x8"
        action_handle: 0x20000018
        is_default_entry: false
        action_parameters_values: []

    instruction: tb_pre_end_0(action, $DEFAULT)
    actions:
      SwitchIngress.pre_end_m_0_compression(0, 3):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000016
      - next_table: 0
      - set ig_md.sip_tmp.i_0, hdr.sip.m_0
      SwitchIngress.pre_end_m_2_compression(1, 4):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000017
      - next_table: 0
      - set ig_md.sip_tmp.i_0, hdr.sip.m_2
      SwitchIngress.pre_end_finalization_a(2, 6):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000018
      - next_table: 0
      - set ig_md.sip_tmp.i_0, 0
      NoAction(-1, 0):
      - hit_allowed: { allowed: false, reason: user_indicated_default_only }
      - default_only_action: { allowed: true }
      - handle: 0x20000019
      - next_table: 0
    default_only_action: NoAction
stage 10 ingress:
  dependency: action
  ternary_match tbl_sip_4_a_0 0:
    p4: { name: tbl_sip_4_a_0, hidden: true }
    hit: [  tbl_sip_4_b_even ]
    miss:  tbl_sip_4_b_even
    indirect: tbl_sip_4_a_0$tind
  ternary_indirect tbl_sip_4_a_0$tind:
    row: 0
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_sip_4_a_0$tind(action, $DEFAULT)
    actions:
      SwitchIngress.sip_4_a(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000001a
      - next_table: 0
      - xor W11, W2, W8
      - xor W12, W7, W9
      - deposit-field W13(0..31), W8(16), W13
    default_action: SwitchIngress.sip_4_a
  ternary_match tbl_sip_4_b_even 3:
    p4: { name: tbl_sip_4_b_even, hidden: true }
    hit: [  tb_recirc_decision_0 ]
    miss:  tb_recirc_decision_0
    indirect: tbl_sip_4_b_even$tind
  ternary_indirect tbl_sip_4_b_even$tind:
    row: 0
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_sip_4_b_even$tind(action, $DEFAULT)
    actions:
      SwitchIngress.sip_4_b_even(0, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000001b
      - next_table: 0
      - xor W10, W7, W14
    default_action: SwitchIngress.sip_4_b_even
stage 11 ingress:
  dependency: match
  exact_match tb_recirc_decision_0 0:
    p4: { name: SwitchIngress.tb_recirc_decision, size: 32 }
    p4_param_order: 
      hdr.sip_meta.curr_round: { type: exact, size: 8, full_size: 8 }
      hdr.ipv4.protocol: { type: exact, size: 8, full_size: 8 }
    row: 7
    bus: 0
    column: [ 2, 3, 4, 5 ]
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - { group: 0, index: 0..9, select: 40..51 & 0x0, rams: [[7, 2]] }
      - { group: 0, index: 10..19, select: 40..51 & 0x0, rams: [[7, 3]] }
      - { group: 0, index: 20..29, select: 40..51 & 0x0, rams: [[7, 4]] }
      - { group: 0, index: 30..39, select: 40..51 & 0x0, rams: [[7, 5]] }
    hash_dist:
      0: { hash: 1, mask: 0xffff, shift: 0 }
      1: { hash: 1, mask: 0xffff, shift: 0 }
    input_xbar:
      exact group 0: { 0: hdr.sip_meta.curr_round, 8: hdr.ipv4.protocol }
      hash 0:
        0..7: random(hdr.ipv4.protocol(2..7)) ^ hdr.sip_meta.curr_round
        8..9: random(hdr.ipv4.protocol(2..7)) ^ hdr.ipv4.protocol(0..1)
        11..18: random(hdr.ipv4.protocol(2..7)) ^ hdr.sip_meta.curr_round
        19: random(hdr.ipv4.protocol(2..7)) ^ hdr.ipv4.protocol(0)
        10: random(hdr.ipv4.protocol(2..7)) ^ hdr.ipv4.protocol(1)
        22..29: random(hdr.ipv4.protocol(2..7)) ^ hdr.sip_meta.curr_round
        20..21: random(hdr.ipv4.protocol(2..7)) ^ hdr.ipv4.protocol(0..1)
        33..39: random(hdr.ipv4.protocol(2..7)) ^ hdr.sip_meta.curr_round(0..6)
        30: random(hdr.ipv4.protocol(2..7)) ^ hdr.sip_meta.curr_round(7)
        31..32: random(hdr.ipv4.protocol(2..7)) ^ hdr.ipv4.protocol(0..1)
      hash group 0:
        table: [0]
        seed: 0xbc63abbd62
      exact group 1: { 0: hdr.sip_meta.v_1, 32: hdr.sip_meta.v_3 }
      hash 2:
        0..15: hdr.sip_meta.v_1(0..15) ^ hdr.sip_meta.v_3(0..15)
      hash group 1:
        table: [2]
        seed: 0x0
      exact group 1: { 0: hdr.sip_meta.v_1, 32: hdr.sip_meta.v_3 }
      hash 2:
        16..31: hdr.sip_meta.v_1(16..31) ^ hdr.sip_meta.v_3(16..31)
      hash group 1:
        table: [2]
        seed: 0x0
    format: { action(0): 0..1, version(0): 112..115, match(0): 34..39, action(1): 2..3, version(1): 116..119, match(1): 42..47, action(2): 4..5, version(2): 120..123, match(2): 50..55, action(3): 6..7, version(3): 124..127, match(3): 58..63 }
    match: [ hdr.ipv4.protocol(2..7) ]
    match_group_map: [ [ 0, 1, 2, 3 ] ]
    hit: [  END ]
    miss:  END
    context_json:
      static_entries:
      - priority: 0
        match_key_fields_values:
        - field_name: hdr.sip_meta.curr_round
          value: "0x0"
        - field_name: hdr.ipv4.protocol
          value: "0xF1"
        action_handle: 0x2000001f
        is_default_entry: false
        action_parameters_values:
        - parameter_name: next_round
          value: "0x2"
      - priority: 1
        match_key_fields_values:
        - field_name: hdr.sip_meta.curr_round
          value: "0x4"
        - field_name: hdr.ipv4.protocol
          value: "0xF1"
        action_handle: 0x2000001f
        is_default_entry: false
        action_parameters_values:
        - parameter_name: next_round
          value: "0x6"
      - priority: 2
        match_key_fields_values:
        - field_name: hdr.sip_meta.curr_round
          value: "0x0"
        - field_name: hdr.ipv4.protocol
          value: "0xF2"
        action_handle: 0x2000001f
        is_default_entry: false
        action_parameters_values:
        - parameter_name: next_round
          value: "0x2"
      - priority: 3
        match_key_fields_values:
        - field_name: hdr.sip_meta.curr_round
          value: "0x4"
        - field_name: hdr.ipv4.protocol
          value: "0xF2"
        action_handle: 0x2000001f
        is_default_entry: false
        action_parameters_values:
        - parameter_name: next_round
          value: "0x6"
      - priority: 4
        match_key_fields_values:
        - field_name: hdr.sip_meta.curr_round
          value: "0x8"
        - field_name: hdr.ipv4.protocol
          value: "0xF2"
        action_handle: 0x20000020
        is_default_entry: false
        action_parameters_values:
        - parameter_name: next_round
          value: "0xA"
      - priority: 5
        match_key_fields_values:
        - field_name: hdr.sip_meta.curr_round
          value: "0x8"
        - field_name: hdr.ipv4.protocol
          value: "0xF1"
        action_handle: 0x2000001f
        is_default_entry: false
        action_parameters_values:
        - parameter_name: next_round
          value: "0xA"

    action_bus: { 96..99 : hash_dist(0, 1) }
    action: tb_recirc_decision_0$action_data($DIRECT, $DEFAULT)
    instruction: tb_recirc_decision_0(action, $DEFAULT)
    actions:
      SwitchIngress.incr_and_recirc(0, 1):
      - p4_param_order: { next_round: 8 }
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x2000001f
      - next_table: 0
      - { next_round: $adf_b0(0..7) }
      - set hdr.sip_meta.curr_round, next_round
      - set ig_intr_md_for_tm.ucast_egress_port, ig_md.rnd_port_for_recirc
      SwitchIngress.do_not_recirc_end_in_eg(1, 2):
      - p4_param_order: { next_round: 8 }
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000020
      - next_table: 0
      - { next_round_2: $adf_b0(0..7), next_round: next_round_2 }
      - set ig_intr_md_for_tm.ucast_egress_port, hdr.sip_meta.dest_port(0..8)
      - set hdr.sip_meta.curr_round, next_round
      SwitchIngress.do_not_recirc_end_in_ig(2, 4):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000021
      - next_table: 0
      - {  }
      - set ig_intr_md_for_tm.ucast_egress_port, hdr.sip_meta.dest_port(0..8)
      - set hdr.sip.m_1, 0
      - set hdr.sip.m_2, 0
      - set hdr.sip.m_3, 0
      - set hdr.sip_meta.$valid, 0
      - set W3(0..31), hash_dist(0, 1, 0..31)
      SwitchIngress.nop(3, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000022
      - next_table: 0
      - {  }
    default_action: SwitchIngress.nop
  action tb_recirc_decision_0$action_data:
    p4: { name: SwitchIngress.tb_recirc_decision$action }
    row: 15
    logical_bus: A
    column: 0
    vpns: [ 0 ]
    home_row:
    - 15
    format SwitchIngress.incr_and_recirc: { $adf_b0: 0..7 }
    format SwitchIngress.do_not_recirc_end_in_eg: { $adf_b0: 0..7 }
    action_bus: { 0 : $adf_b0 }
stage 0 egress:
  exact_match tb_start_round_1 4:
    p4: { name: SwitchEgress.tb_start_round, size: 32 }
    p4_param_order: 
      hdr.sip_meta.curr_round: { type: exact, size: 8, full_size: 8 }
    row: 7
    bus: 0
    column: 2
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - { group: 0, index: 10..19, select: 40..51 & 0x0, rams: [[7, 2]] }
    input_xbar:
      exact group 0: { 56: hdr.sip_meta.curr_round }
      hash 0:
        10..17: hdr.sip_meta.curr_round
      hash group 0:
        table: [0]
        seed: 0x0
    format: { action(0): 0..1, version(0): 112..115, action(1): 2..3, version(1): 116..119, action(2): 4..5, version(2): 120..123, action(3): 6..7, version(3): 124..127, action(4): 8..9, version(4): 16..19 }
    match_group_map: [ [ 0, 1, 2, 3, 4 ] ]
    gateway:
      name: cond-12
      input_xbar:
        exact group 0: { 67: hdr.sip_meta.$valid }
      row: 7
      bus: 1
      unit: 1
      match: { 3: hdr.sip_meta.$valid }
      0x1:
        run_table: true
      miss:
        next:  tbl_halfsiphash842
      condition: 
        expression: "(hdr.sip_meta.$valid == 1)"
        true:  tb_start_round_1
        false:  tbl_halfsiphash842
    hit: [  tbl_sip_1_odd_0 ]
    miss:  tbl_sip_1_odd_0
    context_json:
      static_entries:
      - priority: 0
        match_key_fields_values:
        - field_name: hdr.sip_meta.curr_round
          value: "0x2"
        action_handle: 0x20000025
        is_default_entry: false
        action_parameters_values: []
      - priority: 1
        match_key_fields_values:
        - field_name: hdr.sip_meta.curr_round
          value: "0x6"
        action_handle: 0x20000026
        is_default_entry: false
        action_parameters_values: []
      - priority: 2
        match_key_fields_values:
        - field_name: hdr.sip_meta.curr_round
          value: "0xA"
        action_handle: 0x20000027
        is_default_entry: false
        action_parameters_values: []

    instruction: tb_start_round_1(action, $DEFAULT)
    actions:
      SwitchEgress.start_m_1_compression(1, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000025
      - next_table: 0
      - set eg_md.sip_tmp.i_0, hdr.sip.m_1
      SwitchEgress.start_m_3_compression(2, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000026
      - next_table: 0
      - set eg_md.sip_tmp.i_0, hdr.sip.m_3
      SwitchEgress.start_finalization_b(3, 4):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000027
      - next_table: 0
      - set eg_md.sip_tmp.i_0, 0
      NoAction(-1, 0):
      - hit_allowed: { allowed: false, reason: user_indicated_default_only }
      - default_only_action: { allowed: true }
      - handle: 0x20000028
      - next_table: 0
    default_only_action: NoAction
  ternary_match tbl_halfsiphash842 7:
    p4: { name: tbl_halfsiphash842, hidden: true }
    hit: [  END ]
    miss:  END
    indirect: tbl_halfsiphash842$tind
  ternary_indirect tbl_halfsiphash842$tind:
    row: 1
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_halfsiphash842$tind(action, $DEFAULT)
    actions:
      halfsiphash842(0, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000040
      - next_table: 0
    default_action: halfsiphash842
stage 1 egress:
  dependency: match
  ternary_match tbl_sip_1_odd_0 0:
    p4: { name: tbl_sip_1_odd_0, hidden: true }
    hit: [  tbl_sip_1_b_1 ]
    miss:  tbl_sip_1_b_1
    indirect: tbl_sip_1_odd_0$tind
  ternary_indirect tbl_sip_1_odd_0$tind:
    row: 1
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_sip_1_odd_0$tind(action, $DEFAULT)
    actions:
      SwitchEgress.sip_1_odd(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000029
      - next_table: 0
      - xor W25, W25, W29
    default_action: SwitchEgress.sip_1_odd
stage 2 egress:
  dependency: match
  ternary_match tbl_sip_1_b_1 0:
    p4: { name: tbl_sip_1_b_1, hidden: true }
    hit: [  tbl_sip_1_a_1 ]
    miss:  tbl_sip_1_a_1
    indirect: tbl_sip_1_b_1$tind
  ternary_indirect tbl_sip_1_b_1$tind:
    row: 0
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_sip_1_b_1$tind(action, $DEFAULT)
    actions:
      SwitchEgress.sip_1_b(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000002b
      - next_table: 0
      - deposit-field W28(0..31), W25(24), W28
    default_action: SwitchEgress.sip_1_b
  hash_action tbl_sip_1_a_1 1:
    p4: { name: tbl_sip_1_a_1, hidden: true }
    row: 0
    result_bus: 0
    hash_dist:
      0: { hash: 0, mask: 0xffff, shift: 0 }
      1: { hash: 0, mask: 0xffff, shift: 0 }
    input_xbar:
      exact group 0: { 0: hdr.sip_meta.v_1 }
      hash 0:
        0..4: hdr.sip_meta.v_1(27..31)
        5..15: hdr.sip_meta.v_1(0..10)
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 0: { 0: hdr.sip_meta.v_1 }
      hash 0:
        16..31: hdr.sip_meta.v_1(11..26)
      hash group 0:
        table: [0]
        seed: 0x0
    gateway:
      name: tbl_sip_1_a_1-gateway
      row: 0
      bus: 0
      unit: 0
      0x0:  tbl_sip_2_a_1
      miss:  tbl_sip_2_a_1
      condition: 
        expression: "true(always hit)"
        true:  tbl_sip_2_a_1
        false:  tbl_sip_2_a_1
    next: []
    action_bus: { 96..99 : hash_dist(0, 1) }
    instruction: tbl_sip_1_a_1($DEFAULT, $DEFAULT)
    actions:
      SwitchEgress.sip_1_a(0, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000002a
      - next_table: 0
      - set W18(0..31), hash_dist(0, 1, 0..31)
      - add W26, W22, W23
      - add W27, W19, W25
    default_action: SwitchEgress.sip_1_a
stage 3 egress:
  dependency: action
  ternary_match tbl_sip_2_a_1 0:
    p4: { name: tbl_sip_2_a_1, hidden: true }
    hit: [  tbl_sip_3_a_1 ]
    miss:  tbl_sip_3_a_1
    indirect: tbl_sip_2_a_1$tind
  ternary_indirect tbl_sip_2_a_1$tind:
    row: 0
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_sip_2_a_1$tind(action, $DEFAULT)
    actions:
      SwitchEgress.sip_2_a(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000002c
      - next_table: 0
      - set eg_md.sip_tmp.i_2, eg_md.sip_tmp.a_2
      - xor W20, W27, W28
      - xor W24, W18, W26
      - deposit-field W29(0..31), W26(16), W29
    default_action: SwitchEgress.sip_2_a
stage 4 egress:
  dependency: match
  hash_action tbl_sip_3_a_1 0:
    p4: { name: tbl_sip_3_a_1, hidden: true }
    row: 0
    result_bus: 1
    hash_dist:
      0: { hash: 0, mask: 0xffff, shift: 0 }
      1: { hash: 0, mask: 0xffff, shift: 0 }
    input_xbar:
      exact group 0: { 0: eg_md.sip_tmp.i_1 }
      hash 0:
        0..12: eg_md.sip_tmp.i_1(19..31)
        13..15: eg_md.sip_tmp.i_1(0..2)
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 0: { 0: eg_md.sip_tmp.i_1 }
      hash 0:
        16..31: eg_md.sip_tmp.i_1(3..18)
      hash group 0:
        table: [0]
        seed: 0x0
    gateway:
      name: tbl_sip_3_a_1-gateway
      row: 0
      bus: 0
      unit: 1
      0x0:  tbl_sip_3_b_1
      miss:  tbl_sip_3_b_1
      condition: 
        expression: "true(always hit)"
        true:  tbl_sip_3_b_1
        false:  tbl_sip_3_b_1
    next: []
    action_bus: { 96..99 : hash_dist(0, 1) }
    instruction: tbl_sip_3_a_1($DEFAULT, $DEFAULT)
    actions:
      SwitchEgress.sip_3_a(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000002d
      - next_table: 0
      - set W18(0..31), hash_dist(0, 1, 0..31)
      - add W26, W20, W29
      - add W27, W21, W24
    default_action: SwitchEgress.sip_3_a
  hash_action tbl_sip_3_b_1 2:
    p4: { name: tbl_sip_3_b_1, hidden: true }
    row: 1
    result_bus: 0
    hash_dist:
      4: { hash: 1, mask: 0xffff, shift: 0 }
      5: { hash: 1, mask: 0xffff, shift: 0 }
    input_xbar:
      exact group 1: { 0: eg_md.sip_tmp.i_3 }
      hash 2:
        16..22: eg_md.sip_tmp.i_3(25..31)
        23..31: eg_md.sip_tmp.i_3(0..8)
      hash group 1:
        table: [2]
        seed: 0x0
      exact group 1: { 0: eg_md.sip_tmp.i_3 }
      hash 2:
        32..47: eg_md.sip_tmp.i_3(9..24)
      hash group 1:
        table: [2]
        seed: 0x0
    gateway:
      name: tbl_sip_3_b_1-gateway
      row: 1
      bus: 0
      unit: 0
      0x0:  tbl_sip_4_a_1
      miss:  tbl_sip_4_a_1
      condition: 
        expression: "true(always hit)"
        true:  tbl_sip_4_a_1
        false:  tbl_sip_4_a_1
    next: []
    action_bus: { 104..107 : hash_dist(4, 5) }
    instruction: tbl_sip_3_b_1($DEFAULT, $DEFAULT)
    actions:
      SwitchEgress.sip_3_b(0, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000002e
      - next_table: 0
      - set W28(0..31), hash_dist(4, 5, 0..31)
    default_action: SwitchEgress.sip_3_b
stage 5 egress:
  dependency: action
  ternary_match tbl_sip_4_a_1 1:
    p4: { name: tbl_sip_4_a_1, hidden: true }
    hit: [  tbl_sip_4_b_odd_0 ]
    miss:  tbl_sip_4_b_odd_0
    indirect: tbl_sip_4_a_1$tind
  ternary_indirect tbl_sip_4_a_1$tind:
    row: 0
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_sip_4_a_1$tind(action, $DEFAULT)
    actions:
      SwitchEgress.sip_4_a(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000002f
      - next_table: 0
      - deposit-field W19(0..31), W27(16), W19
      - xor W23, W18, W27
      - xor W25, W26, W28
    default_action: SwitchEgress.sip_4_a
  ternary_match tbl_sip_4_b_odd_0 2:
    p4: { name: tbl_sip_4_b_odd_0, hidden: true }
    hit: [  tbl_sip_1_b_2 ]
    miss:  tbl_sip_1_b_2
    indirect: tbl_sip_4_b_odd_0$tind
  ternary_indirect tbl_sip_4_b_odd_0$tind:
    row: 0
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_sip_4_b_odd_0$tind(action, $DEFAULT)
    actions:
      SwitchEgress.sip_4_b_odd(0, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000030
      - next_table: 0
      - set hdr.sip_meta.v_0, eg_md.sip_tmp.a_0
    default_action: SwitchEgress.sip_4_b_odd
stage 6 egress:
  dependency: match
  ternary_match tbl_sip_1_b_2 1:
    p4: { name: tbl_sip_1_b_2, hidden: true }
    hit: [  tbl_sip_1_a_2 ]
    miss:  tbl_sip_1_a_2
    indirect: tbl_sip_1_b_2$tind
  ternary_indirect tbl_sip_1_b_2$tind:
    row: 0
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_sip_1_b_2$tind(action, $DEFAULT)
    actions:
      SwitchEgress.sip_1_b(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000032
      - next_table: 0
      - deposit-field W28(0..31), W25(24), W28
    default_action: SwitchEgress.sip_1_b
  hash_action tbl_sip_1_a_2 2:
    p4: { name: tbl_sip_1_a_2, hidden: true }
    row: 0
    result_bus: 0
    hash_dist:
      0: { hash: 0, mask: 0xffff, shift: 0 }
      1: { hash: 0, mask: 0xffff, shift: 0 }
    input_xbar:
      exact group 0: { 0: hdr.sip_meta.v_1 }
      hash 0:
        0..4: hdr.sip_meta.v_1(27..31)
        5..15: hdr.sip_meta.v_1(0..10)
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 0: { 0: hdr.sip_meta.v_1 }
      hash 0:
        16..31: hdr.sip_meta.v_1(11..26)
      hash group 0:
        table: [0]
        seed: 0x0
    gateway:
      name: tbl_sip_1_a_2-gateway
      row: 0
      bus: 0
      unit: 0
      0x0:  tbl_sip_2_a_2
      miss:  tbl_sip_2_a_2
      condition: 
        expression: "true(always hit)"
        true:  tbl_sip_2_a_2
        false:  tbl_sip_2_a_2
    next: []
    action_bus: { 96..99 : hash_dist(0, 1) }
    instruction: tbl_sip_1_a_2($DEFAULT, $DEFAULT)
    actions:
      SwitchEgress.sip_1_a(0, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000031
      - next_table: 0
      - set W18(0..31), hash_dist(0, 1, 0..31)
      - add W26, W22, W23
      - add W27, W19, W25
    default_action: SwitchEgress.sip_1_a
stage 7 egress:
  dependency: action
  ternary_match tbl_sip_2_a_2 2:
    p4: { name: tbl_sip_2_a_2, hidden: true }
    hit: [  tbl_sip_3_a_2 ]
    miss:  tbl_sip_3_a_2
    indirect: tbl_sip_2_a_2$tind
  ternary_indirect tbl_sip_2_a_2$tind:
    row: 0
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_sip_2_a_2$tind(action, $DEFAULT)
    actions:
      SwitchEgress.sip_2_a(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000033
      - next_table: 0
      - set eg_md.sip_tmp.i_2, eg_md.sip_tmp.a_2
      - xor W20, W27, W28
      - xor W24, W18, W26
      - deposit-field W29(0..31), W26(16), W29
    default_action: SwitchEgress.sip_2_a
stage 8 egress:
  dependency: match
  hash_action tbl_sip_3_a_2 1:
    p4: { name: tbl_sip_3_a_2, hidden: true }
    row: 0
    result_bus: 1
    hash_dist:
      0: { hash: 0, mask: 0xffff, shift: 0 }
      1: { hash: 0, mask: 0xffff, shift: 0 }
    input_xbar:
      exact group 0: { 0: eg_md.sip_tmp.i_1 }
      hash 0:
        0..12: eg_md.sip_tmp.i_1(19..31)
        13..15: eg_md.sip_tmp.i_1(0..2)
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 0: { 0: eg_md.sip_tmp.i_1 }
      hash 0:
        16..31: eg_md.sip_tmp.i_1(3..18)
      hash group 0:
        table: [0]
        seed: 0x0
    gateway:
      name: tbl_sip_3_a_2-gateway
      row: 0
      bus: 0
      unit: 1
      0x0:  tbl_sip_3_b_2
      miss:  tbl_sip_3_b_2
      condition: 
        expression: "true(always hit)"
        true:  tbl_sip_3_b_2
        false:  tbl_sip_3_b_2
    next: []
    action_bus: { 96..99 : hash_dist(0, 1) }
    instruction: tbl_sip_3_a_2($DEFAULT, $DEFAULT)
    actions:
      SwitchEgress.sip_3_a(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000034
      - next_table: 0
      - set W18(0..31), hash_dist(0, 1, 0..31)
      - add W26, W20, W29
      - add W27, W21, W24
    default_action: SwitchEgress.sip_3_a
  hash_action tbl_sip_3_b_2 2:
    p4: { name: tbl_sip_3_b_2, hidden: true }
    row: 0
    result_bus: 0
    hash_dist:
      2: { hash: 0, mask: 0xffff, shift: 0 }
      3: { hash: 1, mask: 0xffff, shift: 0 }
    input_xbar:
      exact group 0: { 32: eg_md.sip_tmp.i_3 }
      hash 0:
        32..38: eg_md.sip_tmp.i_3(25..31)
        39..47: eg_md.sip_tmp.i_3(0..8)
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 0: { 64: eg_md.sip_tmp.i_3 }
      hash 1:
        0..15: eg_md.sip_tmp.i_3(9..24)
      hash group 1:
        table: [1]
        seed: 0x0
    gateway:
      name: tbl_sip_3_b_2-gateway
      row: 0
      bus: 0
      unit: 0
      0x0:  tb_pre_end_1
      miss:  tb_pre_end_1
      condition: 
        expression: "true(always hit)"
        true:  tb_pre_end_1
        false:  tb_pre_end_1
    next: []
    action_bus: { 100..103 : hash_dist(2, 3) }
    instruction: tbl_sip_3_b_2($DEFAULT, $DEFAULT)
    actions:
      SwitchEgress.sip_3_b(0, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000035
      - next_table: 0
      - set W28(0..31), hash_dist(2, 3, 0..31)
    default_action: SwitchEgress.sip_3_b
  exact_match tb_pre_end_1 3:
    p4: { name: SwitchEgress.tb_pre_end, size: 32 }
    p4_param_order: 
      hdr.sip_meta.curr_round: { type: exact, size: 8, full_size: 8 }
    row: 7
    bus: 0
    column: 2
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - { group: 2, index: 0..9, select: 40..51 & 0x0, rams: [[7, 2]] }
    input_xbar:
      exact group 1: { 0: hdr.sip_meta.curr_round }
      hash 2:
        0..7: hdr.sip_meta.curr_round
      hash group 2:
        table: [2]
        seed: 0x0
    format: { action(0): 0..1, version(0): 112..115, action(1): 2..3, version(1): 116..119, action(2): 4..5, version(2): 120..123, action(3): 6..7, version(3): 124..127, action(4): 8..9, version(4): 16..19 }
    match_group_map: [ [ 0, 1, 2, 3, 4 ] ]
    hit: [  tbl_sip_4_a_2 ]
    miss:  tbl_sip_4_a_2
    context_json:
      static_entries:
      - priority: 0
        match_key_fields_values:
        - field_name: hdr.sip_meta.curr_round
          value: "0x2"
        action_handle: 0x20000036
        is_default_entry: false
        action_parameters_values: []
      - priority: 1
        match_key_fields_values:
        - field_name: hdr.sip_meta.curr_round
          value: "0x6"
        action_handle: 0x20000037
        is_default_entry: false
        action_parameters_values: []
      - priority: 2
        match_key_fields_values:
        - field_name: hdr.sip_meta.curr_round
          value: "0xA"
        action_handle: 0x20000038
        is_default_entry: false
        action_parameters_values: []

    instruction: tb_pre_end_1(action, $DEFAULT)
    actions:
      SwitchEgress.pre_end_m_1_compression(0, 3):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000036
      - next_table: 0
      - set eg_md.sip_tmp.i_0, hdr.sip.m_1
      SwitchEgress.pre_end_m_3_compression(1, 4):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000037
      - next_table: 0
      - set eg_md.sip_tmp.i_0, hdr.sip.m_3
      SwitchEgress.start_finalization_b(2, 6):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000038
      - next_table: 0
      - set eg_md.sip_tmp.i_0, 0
      NoAction(-1, 0):
      - hit_allowed: { allowed: false, reason: user_indicated_default_only }
      - default_only_action: { allowed: true }
      - handle: 0x20000039
      - next_table: 0
    default_only_action: NoAction
stage 9 egress:
  dependency: action
  ternary_match tbl_sip_4_a_2 2:
    p4: { name: tbl_sip_4_a_2, hidden: true }
    hit: [  tbl_sip_4_b_even_0 ]
    miss:  tbl_sip_4_b_even_0
    indirect: tbl_sip_4_a_2$tind
  ternary_indirect tbl_sip_4_a_2$tind:
    row: 1
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_sip_4_a_2$tind(action, $DEFAULT)
    actions:
      SwitchEgress.sip_4_a(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000003a
      - next_table: 0
      - deposit-field W19(0..31), W27(16), W19
      - xor W23, W18, W27
      - xor W25, W26, W28
    default_action: SwitchEgress.sip_4_a
  ternary_match tbl_sip_4_b_even_0 4:
    p4: { name: tbl_sip_4_b_even_0, hidden: true }
    hit: [  tbl_halfsiphash872 ]
    miss:  tbl_halfsiphash872
    indirect: tbl_sip_4_b_even_0$tind
  ternary_indirect tbl_sip_4_b_even_0$tind:
    row: 0
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_sip_4_b_even_0$tind(action, $DEFAULT)
    actions:
      SwitchEgress.sip_4_b_even(0, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000003b
      - next_table: 0
      - xor W22, W26, W29
    default_action: SwitchEgress.sip_4_b_even
  ternary_match tbl_halfsiphash872 5:
    p4: { name: tbl_halfsiphash872, hidden: true }
    gateway:
      name: cond-13
      input_xbar:
        exact group 1: { 9: hdr.sip_meta.curr_round(1..7) }
        hash 2:
          44..46: hdr.sip_meta.curr_round(5..7)
          40..43: hdr.sip_meta.curr_round(1..4)
        hash group 2:
          table: [2]
          seed: 0x0
      row: 7
      bus: 0
      unit: 0
      match: { 36: hdr.sip_meta.curr_round(5..7), 32: hdr.sip_meta.curr_round(1..4) }
      range: 4
      ? [ 0x0, 0xffff, * ] :
        run_table: true
      ? [ 0x101, 0x1f, * ] :
        run_table: true
      miss:
        next:  tbl_halfsiphash877
      condition: 
        expression: "(hdr.sip_meta.curr_round < 10)"
        true:  tbl_halfsiphash872
        false:  tbl_halfsiphash877
    hit: [  END ]
    miss:  END
    indirect: tbl_halfsiphash872$tind
  ternary_indirect tbl_halfsiphash872$tind:
    row: 0
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_halfsiphash872$tind(action, $DEFAULT)
    actions:
      halfsiphash872(1, 3):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000003c
      - next_table: 0
      - add B16, 2, B16
    default_action: halfsiphash872
  ternary_match tbl_halfsiphash877 6:
    p4: { name: tbl_halfsiphash877, hidden: true }
    gateway:
      name: cond-14
      input_xbar:
        exact group 1: { 16: hdr.ipv4.protocol }
      row: 0
      bus: 0
      unit: 0
      match: { 0: hdr.ipv4.protocol }
      0xf1:
        run_table: true
      miss:
        next:  tbl_final_round_svf
      condition: 
        expression: "(hdr.ipv4.protocol == 241)"
        true:  tbl_halfsiphash877
        false:  tbl_final_round_svf
    hit: [  tbl_final_round_revf ]
    miss:  tbl_final_round_revf
    indirect: tbl_halfsiphash877$tind
  ternary_indirect tbl_halfsiphash877$tind:
    row: 1
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_halfsiphash877$tind(action, $DEFAULT)
    actions:
      halfsiphash877(1, 4):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000003d
      - next_table: 0
      - set hdr.sip_meta.curr_round, 0
    default_action: halfsiphash877
stage 10 egress:
  dependency: match
  hash_action tbl_final_round_svf 1:
    p4: { name: tbl_final_round_svf, hidden: true }
    row: 0
    result_bus: 1
    hash_dist:
      0: { hash: 0, mask: 0xffff, shift: 0 }
      1: { hash: 0, mask: 0xffff, shift: 0 }
    input_xbar:
      exact group 0: { 0: hdr.sip_meta.v_1, 32: hdr.sip_meta.v_3 }
      hash 0:
        0..15: hdr.sip_meta.v_1(0..15) ^ hdr.sip_meta.v_3(0..15)
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 0: { 0: hdr.sip_meta.v_1, 32: hdr.sip_meta.v_3 }
      hash 0:
        16..31: hdr.sip_meta.v_1(16..31) ^ hdr.sip_meta.v_3(16..31)
      hash group 0:
        table: [0]
        seed: 0x0
    gateway:
      name: tbl_final_round_svf-gateway
      row: 0
      bus: 0
      unit: 1
      0x0:  END
      miss:  END
      condition: 
        expression: "true(always hit)"
        true:  END
        false:  END
    next: []
    action_bus: { 96..99 : hash_dist(0, 1) }
    instruction: tbl_final_round_svf($DEFAULT, $DEFAULT)
    actions:
      SwitchEgress.final_round_svf(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000003f
      - next_table: 0
      - set hdr.sip.m_0, hdr.sip_meta.revf_result
      - set hdr.sip_meta.$valid, 0
      - set W17(0..31), hash_dist(0, 1, 0..31)
    default_action: SwitchEgress.final_round_svf
  hash_action tbl_final_round_revf 2:
    p4: { name: tbl_final_round_revf, hidden: true }
    row: 0
    result_bus: 0
    hash_dist:
      0: { hash: 0, mask: 0xffff, shift: 0 }
      1: { hash: 0, mask: 0xffff, shift: 0 }
    input_xbar:
      exact group 0: { 0: hdr.sip_meta.v_1, 32: hdr.sip_meta.v_3 }
      hash 0:
        0..15: hdr.sip_meta.v_1(0..15) ^ hdr.sip_meta.v_3(0..15)
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 0: { 0: hdr.sip_meta.v_1, 32: hdr.sip_meta.v_3 }
      hash 0:
        16..31: hdr.sip_meta.v_1(16..31) ^ hdr.sip_meta.v_3(16..31)
      hash group 0:
        table: [0]
        seed: 0x0
    gateway:
      name: tbl_final_round_revf-gateway
      row: 0
      bus: 0
      unit: 0
      0x0:  END
      miss:  END
      condition: 
        expression: "true(always hit)"
        true:  END
        false:  END
    next: []
    action_bus: { 100..103 : hash_dist(0, 1) }
    instruction: tbl_final_round_revf($DEFAULT, $DEFAULT)
    actions:
      SwitchEgress.final_round_revf(0, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000003e
      - next_table: 0
      - set hdr.sip.m_1, 0
      - set hdr.sip.m_2, 0
      - set hdr.sip.m_3, 0
      - set hdr.sip.m_0, hdr.sip.m_4
      - set W33(0..31), hash_dist(0, 1, 0..31)
    default_action: SwitchEgress.final_round_revf


primitives: "halfsiphash.prim.json"
dynhash: "halfsiphash.dynhash.json"
